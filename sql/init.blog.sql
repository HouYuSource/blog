/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50724
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50724
 File Encoding         : 65001

 Date: 05/11/2019 08:56:32
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `catalog_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `catalog_name` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_size` int(11) NULL DEFAULT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `create_date` datetime(0) NULL DEFAULT NULL,
  `display_img` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `html_content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `can_comment` int(11) NULL DEFAULT NULL,
  `read_size` int(11) NULL DEFAULT NULL,
  `status` int(11) NULL DEFAULT NULL,
  `summary` varchar(300) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `tags` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `user_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `vote_size` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('1150038168796479488', '1150036060646944768', 'A01_不分类', 2, '> 最近稍微空闲了一点, 找时间完善一下博客, 然后移除了小程序端, 主要就是觉得有点累赘( 由于一开始使用原生的微信控件写的, 不好维护, 样式丑等问题  )  还不如直接搞一个H5页面(我司有在玩这个, 了解到一些, 感觉还不错, 有时间的话可以玩这个 , 目前的移动端展示是使用网页端的适配, 这个花了我不少时间啊!!!  然后写了一坨乱七八糟的适配代码...\n\n## 关于Shy Site\nShy Site站是一个即将开源的Java项目 ( 个人站点 / 博客 ) , 整体代码已完成, 等过几天review一下代码, 再push一下。\n后面还会专门写几篇关于博客快速搭建以及部署的文章。\n* 前端展示: <a href=\"https://shaines.cn\" target=\"_blank\">https://shaines.cn</a> [尽可能适配移动端]\n* 后端管理: <a href=\"https://admin.shaines.cn\" target=\"_blank\">https://admin.shaines.cn</a> [尚未适配移动端]\n	username: test\n	password: test\n\n### 技术栈\n* springboot2.14\n* spring mvc\n* JPA\n* vue-xuAdmin(后台管理模板) <a href=\"https://github.com/Nirongxu/vue-xuAdmin\" target=\"_blank\">https://github.com/Nirongxu/vue-xuAdmin</a> \n* element-ui\n* layui\n\n主要功能有如下(包括整体部署):\n* 自定义权限注解实现功能权限的划分\n* 自定义拦截器实现全局日志记录\n* 自定义拦截器实现拦截恶意请求\n* 博客的草稿保存\n* 博客发布\n* 评论审核\n* 评论回复\n* 点赞\n* 访问统计\n* 数据分析\n* 点赞 / 评论 状态跟进,邮件异步通知\n* 适配移动端( 尽可能适配, 局部尚未适配完全 )\n* jar部署\n* nginx https 配置 [感谢我司大佬K.]\n* nginx端口转发\n* 后台管理系统静态资源部署\n* 解决JWT登录不失效问题\n\n\n### 历史版本\n* #### V1.0.0 是一个基于多用户的博客系统\n\n1. <a href=\"https://shaines.cn/?details=1150323302640689152\" target=\"_blank\">博客V1.0.0版本说明</a>\n\n* #### V2.0.0 是一个个人站点 , 界面如下\n1. 前台显示\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727154836916.png)\n2. 管理中心展示\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727154851502.png)\n\n## 关于我\n97的后端程序员Shy [ [后宇](https://shaines.cn) ], 是一个关注编程, 热爱技术的开发者, 热衷于 `网站后端开发`, `数据爬虫`, `大数据领域`。\n\n在这里会一直记录着我成长的点点滴滴， 毕竟好记性不如烂笔头， 如果你在我的博客中有所收获， 这也将是我毕生的荣幸。\n\n* GitHub\nhttps://github.com/HouYuSource\n\n* CSDN\nhttps://blog.csdn.net/jinglongsource\n\n* 联系我\nfor.houyu@foxmail.com\nfor.houyu@qq.com\n\n### 特别鸣谢\n* vue-xuAdmin \n是基于vue2.0全家桶 + element-ui 开发的一个后台模板，实现了无限级菜单，页面、按钮级别的权限管理\nhttps://github.com/Nirongxu/vue-xuAdmin\n', '2019-07-13 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/2019072019121980.png', NULL, 1, 104, 1, '关于本站, 关于我', '关于,博客说明', '关于本站, 关于我', '20190713', 'houyu', 2);
INSERT INTO `blog` VALUES ('1150323302640689152', '1150036060646944768', 'A01_不分类', 0, '## 博客V1.0.0版本上线说明:\n\n---\n\n#### 总的分为以下几点说明:\n\n `1.博客的背景`\n\n `2.博客的技术实现`\n\n `3.博客简单介绍`\n\n `4.博客的原型`\n\n `5.博客的后续考虑`\n\n---\n\n> ### 1.博客的背景\n\n博客的背景:即将毕业 (还没拍毕业照呢`2018-11-23毕业照,有空的小伙伴,你懂的啦!!!`) 想构建一个个人技术博客,记录自己在学习中遇到的种种问题以及分享解决方法。一是可以方便自己总结积累，二是如果别人刚好在我博客上有所收获的话那也是我毕生的荣耀呀。好吧，就这么滴介绍小背景吧~~  \n\n---\n\n> ### 2.博客的技术实现\n首先先说这个博客V1.0.0版本用到了那些技术吧.\n\n+ 1.`gradle`构建工程;\n\n+ 2.`springboot`快速搭建架构;\n\n+ 3.数据库方面:`H2`调试使用,`mysql`上线使用持久化数据库,`MogoDB`文件系统(用于上传图片等文件);\n\n+ 4.前端:`Thymeleaf`,`Bootstrap`,`JavaScript`,`jQuery`;\n\n+ 5.后端：`Spring Boot`, `Spring MVC`, `Spring Security`;\n\n+ 6.数据库操作：`Spring Data JPA`,`Hibernate`,`Spring JdbcTemplate`;\n\n+ 7.其他框架 or 工具：`Markdown`,`ElasticSearch`全文搜索引擎框架被我干掉了,搜索方面使用了自己写的一个工具类实现;\n\n---\n\n> ### 3.博客简单介绍\n\n在博客的首页可以看到最新发布的博客,点击`最新` and `最热`即可切换到对用的板块,其中 最新 是根据发布时间排序,最热 根据博客的`查看`人数,`评论`人数,`点赞`进行综合排序.\n\n点击具体博客可以进去查看博客的详情,点击用户即可进入到用户主页,用户主页有用户的所有博客(博客分类,博客标签,博客列表等)\n\n---\n\n> ### 4.博客的原型\n\n博客的背景也介绍到了,因为想要快速搭建博客,所以肯定是先找是否有现有的案例啦,我找了很久,找到了[慕课网](https://www.imooc.com \"慕课网\")的一个springboot博客系统的项目,有兴趣可以去看看,个人觉得很不错,值得推荐!!!,我就是源于此,按照教程一步一步敲,遇到了很多问题,这期间那个叫郁闷呀,养成了一句口头禅,`\"怎么他可以我不可以\"`,直接上手springboot就做项目,遇到点问题肯定正常的,所以博客项目之后我还得接着深入了解springboot...\n\n不过也很荣幸,通过这次我和[百度](https://www.baidu.com \"百度\")再次达成深度合作的关系,当然还少不了[google](https://www.google.com.hk \"google\")提供技术支持\n\n---\n\n> ### 5.博客的后续考虑\n\n1. 评论方面:\n\n      A:目前的评论只需要添加username & email 即可评论以及点赞,并且未对特殊字符绿色化处理`说白了就和谐`,接下来会进行一个特殊字符校验机制;\n\n      B:考虑加上注册用户需要填上邮箱验证码进行注册,然后才可以评论,开启审核机制,等有时间了继续完善一下.\n\n2. 权限方面:\n\n      A:填写了评论的用户可以根据 `username` 自行到[SHY BLOG](http://shaines.cn/login \"SHY BLOG\")进行修改用户的头像,但是不建议修改,一是我限制了图片大小,二是我服务器硬盘小了,我会清的[捂脸]\n\n      B:目前的用户还不可以编写博客,因为我限权了,我怕我强大的9.5元/月学生入门级服务器折腾不起啊。后期考虑开启用户编写博客的权限。\n\n---\n\n> ### 6.界面展示\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727154736172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n#### 好了  ...\n\n就那么多吧  \n\n第一次使用Markdown语法，不是很熟悉，丑了点，理解下！！！哈哈~~~\n\n最后的最后~  \n\n-----------特别鸣谢-----------\n\n[老卫](https://waylau.com \"老卫\"),   [y俊杰](https://www.baidu.com \"y俊杰\"),   [p汉涛](http://www.oakblog.cn \"p汉涛\")等好友提供的帮助。\n\n感谢宿友忍受我半夜啪啪啪啪啪啪的声音~~\n\n`(注:手机端评论和点赞可能失效,看到8080端口,是不是很熟悉呀[捂脸],备案还没下来~[捂脸])`\n\n![img](https://shaines.cn/view/image?src=https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/01/56850004c85d256d5079.gif \"调试BUG\")\n\n![img](https://shaines.cn/view/image?src=http://5b0988e595225.cdn.sohucs.com/images/20171013/c90f229697cf4061988642d385bb6ef4.jpeg \"调试BUG\")\n\n`机智点,码代码呢[捂脸]`', '2018-11-18 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190720193100220.png', NULL, 1, 364, 1, '说点心里话。', '博客说明', '博客V1.0.0版本说明', '20190713', 'houyu', 15);
INSERT INTO `blog` VALUES ('1150324977199783936', '1154242259585789952', 'A06_部署', 0, '\n---\n### 步骤01\n上[百度](http://www.baidu.com \"百度\") or [google](https://www.google.com.hk/ \"google\")搜过关键字 `\"阿里云 学生\"` 找到`云翼计划`(如下图)\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316231133486.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n### 步骤02\n进入`云翼计划`,你会看到很直接很亲切的页面,直接下单即可~~~\n\n---注意事项在图片注明了---\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316231152778.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n### 步骤03\n\n下完单之后,你就顺着提示进入到`阿里云`官网\n\n(我这里直接搜索引入的)\n\n那么刚才买的服务器在哪了呢?按照图片提示,在搜索框装输入`“轻量级服务器 控制台”` enter 之后不出意外的话你会进入到步骤04。\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316231210128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n### 步骤04\n\n如果步骤03不出意外的话，你会进入到这个页面，这个就是你刚才购买的服务器啦~~\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316231225280.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n### 步骤05\n点击·服务器小卡片·即可进入查看服务器的详情信息（如下界面）\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316231241741.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n---\n### 步骤06\n按照下图提示页面 `01 -> 02 -> 03` 操作.\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316231257814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n### 步骤07\n还是按照提示一步一步执行即可,不出意外的话~~\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316231310140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n### 步骤08\n进入到 宝塔控制面板首页 注意事项请留意图片说明。\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316231323676.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n### 完毕啦~~\n\n当你按照流程走到这里的时候你就顺利搭建好服务器啦!!\n\n恭喜恭喜啊   哈哈哈\n\n然后你就可以在服务器上面部署自己的应用程序啦,如果不知道如何操作,请自行百度,或者期待我的下一篇博客\n\n`如何使用宝塔面板部署war包项目`\n\n---------特别鸣谢---------\n\n非常感谢[jun19](http://www.baidu.com \"jun19\")提供的指导,让我少走很多弯路~~\n\n`如有不妥,请联系我修正,如有类同,纯属巧合~`\n\n本人已和[百度](http://www.baidu.com \"百度\")达成深度合作的关系，如果还有什么问题的话，请百度。\n\n本人已和[阿里](https://selfservice.console.aliyun.com \"阿里\")达成深度合作的关系，如果还有什么问题的话，请客服。\n\n', '2018-11-19 00:00:00', 'https://shaines.cn/view/image?src=https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/01/56850004c85d256d5079.gif', NULL, 1, 156, 1, '从0开始搭建阿里云服务器', '部署', '从0开始搭建阿里云服务器', '20190713', 'houyu', 10);
INSERT INTO `blog` VALUES ('1150325471418818560', '1154242259585789952', 'A06_部署', 0, '---\n### 直入话题\n看博客之前你应该有一个完整可以跑的项目,`hello world`以上Web的项目,在这里不对打war包做详细介绍,可以自行百度 `maven打war包` or `gradle打war包`, 或者期待我下一次作打war包做介绍,所以这里假装你有一个可以跑的war包和项目需要的sql文件了。还有一个前提是你的环境和我 `%搭建服务器&`中的博客环境一致,否则出现未知问题,那就GG~~\n\n---\n\n#### 步骤01:\n\n   * 浏览器 打开 `\"宝塔控制面板\"`(如下图)[默认是 ip:8888]如何登陆在`%搭建服务器&`介绍了~~\n   ![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316231932999.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n\n#### 步骤02:\n\n   * 导入数据库(如果不需要导入数据库跳过步骤02即可)\n\n   ![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/2019031623194766.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n   * 接着\n\n  ![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316232002379.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n   * 接着就选择导入即可~~感觉比在本机(window)还要方便有木有[捂脸]\n\n---\n\n#### 步骤03:\n\n   * 找到tomcat目录\n\n   ![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316232024514.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n\n#### 步骤04:\n\n   * 找到tomcat > webapps目录\n\n   ![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/201903162320379.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n---\n\n#### 步骤05:\n\n   * 找到tomcat > webapps目录进行上传war包\n\n   ![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316232051196.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70) \n\n---\n\n#### 步骤06:\n\n   * 确保tomcat启动\n\n   ![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316232104349.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n---\n\n#### 步骤07:\n\n   * 测试是否跑通~~(不出意外的话)\n\n   ![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316232114336.jpg) \n\n\n   * OK啦啦~~\n\n---\n\n##### 追加说明:\n\n   * 这是基本操作的方式,那么想:8080 直接就是访问项目了怎么设置呢??\n       1. 去到webapps目录下把你的项目文件夹更名为 `ROOT`\n\n       2. 配置tomcat的根目录/conf/server.xml修改参数\n\n              <Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\">\n            	<Context path=\"\" docBase=\"blog\" reloadable=\"true\" />\n                <Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log\" suffix=\".txt\" pattern=\"%h %l %u %t &quot;%r&quot; %s %b\"/>\n              </Host>\n\n\n---\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190316232147712.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)', '2018-11-20 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190720192931202.png', NULL, 1, 307, 1, '如何使用宝塔面板部署war包项目', '部署', '如何使用宝塔面板部署war包项目', '20190713', 'houyu', 5);
INSERT INTO `blog` VALUES ('1150326021145272320', '1154239164080386048', 'A03_PYTHON', 0, '### 前言\n> 有一次在上课的时候看到[jun19](#)在浏览一个网站买东西(hhh),我大致看了一眼,该网站可以看到该件商品在不同商城的价格,我觉得有点意思,然后我就和他深入了解了一下该[网站:(慢慢买)](http://help.manmanbuy.com/),我就想要是爬下来,那就可以玩一下呀,然后我就找个时间写一下爬虫...\n\n\n好了,不扯了..,直入主题吧~\n\n---\n\n### 实现前提:\n如果你想实现的话:\n\n* 一定的网页基础\n* 网站抓包\n* python基础\n* 了解python爬虫框架scrapy\n\n---\n\n### 步骤01:分析网页\n\n主要的详情说明已在图片上做了说明:\n\n![](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy1zaGFpbmVzLTEyNTgxOTMxMzcuY29zLmFwLWd1YW5nemhvdS5teXFjbG91ZC5jb20vJUU2JTg1JUEyJUU2JTg1JUEyJUU0JUI5JUIwJUU2JUFEJUE1JUU5JUFBJUE0MDEwMS5qcGc) \n\n---\n\n### 步骤02:分析网页url以及response\n\n* url:`http://s.manmanbuy.com/Default.aspx?key=%C6%BB%B9%FB8&btnSearch=%CB%D1%CB%F7`\n首先经验告诉我们,这个url是经过url编码的,所以我们通过url 解码之后的真实url应该是\nurl_real:`http://s.manmanbuy.com/Default.aspx?key=苹果8&btnSearch=搜索`\n\n  看着很亲切的参数出来了`\"苹果8\"`,后面的参数可以省略...\n  所以我们只需要通过改变url即可得到不同列表的数据了`http://s.manmanbuy.com/Default.aspx?key=你想要的搜索的商品名称` (\'你想要的搜索的商品名称\'需要经过url gbk encode)\n\n* response:说白了就是字符串,也就是html\n  通过查看源代码我们可以知道网页上的数据都在response中\n  \n  ![](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy1zaGFpbmVzLTEyNTgxOTMxMzcuY29zLmFwLWd1YW5nemhvdS5teXFjbG91ZC5jb20vJUU2JTg1JUEyJUU2JTg1JUEyJUU0JUI5JUIwJUU2JUFEJUE1JUU5JUFBJUE0MDIwMS5qcGc) \n\n\n---\n\n### 步骤03:编写爬虫(scrapy.Spider)\n\n* 直接上代码如下:\n\n        class TestSpider01(scrapy.Spider):\n\n            def __init__(self):\n                self.pipeline_utils = PipelineUtils()\n                self.print_utils = PrintUtils()\n                self.parse_utils = ParseUtils()\n                self.redis_utils = RedisUtils()\n                self.http_utils = HttpUtils()\n                self.utils = Utils()\n                dispatcher.connect(self.spider_closed, signals.spider_closed)\n\n            def spider_closed(self, spider):\n                self.print_utils.send_message(self.name, PrintUtils().print_end())  # 打印结束标志\n\n            name = \'TestSpider01\'\n\n            custom_settings = {\n                \'DEFAULT_REQUEST_HEADERS\': {\n                    \'Accept\': \"*/*\",\n                    \'Accept-Language\': \"zh-CN,zh;q=0.8\",\n                    \'Accept-Encoding\': \'gzip, deflate\',\n                    \'Connection\': \'keep-alive\',\n                    \'Referer\': \'http://s.manmanbuy.com/\',\n                    \'User-Agent\': \'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36\',\n                    \'Upgrade-Insecure-Requests\': \'1\',\n                },\n                \'LOG_LEVEL\': \'ERROR\',\n                # \"COOKIES_ENABLED\": True, # 开启COOKIES\n            }\n\n            start_url = \'http://s.manmanbuy.com/Default.aspx?key=苹果8\'\n            #            http://s.manmanbuy.com/Default.aspx?key=%C6%BB%B9%FB8&btnSearch=%CB%D1%CB%F7\n\n            def start_requests(self):\n                start_url = self.utils.url_encode(self.start_url, encoding=\'GBK\')  # self.utils.url_encode() 封装的是 : parse.quote(text_str, encoding=encoding)\n                yield scrapy.Request(url=start_url, callback=self.parse)\n\n            def parse(self, response):\n                # html_str = response.text\n                # current_url = response.url\n                print(\"+++>>\" + response.url)\n\n                select = scrapy.Selector(response)\n                divs = select.xpath(\'//*[@id=\"listpro\"]/div/div[@class=\"div1100\"]/div\')\n                for one_div in divs:\n                    goods_title =  \'\'.join(one_div.xpath(\'./div[@class=\"title\"]/div[@class=\"t\"]//*/text()\').extract()).strip()\n                    if not goods_title: continue # 如果标题为空,说明不是一个有效的div,跳过该div获取数据流程\n\n                    data_dict = OrderedDict()\n                    data_dict[\'商品标题\'] = goods_title\n\n                    # 这有一个问题就是 个别url是: \'/productdetail.aspx?itemid=558550356564&skuid=\'\n                    # 通过慢慢买官网我们可以知道实质链接是:\'https://detail.tmall.com/item.htm?id=558550356564&sku_properties=10004:709990523;5919063:6536025;12304035:3222911\'\n                    # 有效的部分是 \'https://detail.tmall.com/item.htm?id=558550356564\',所以这里要做一个转换\n                    goods_href = str(one_div.xpath(\'./div[@class=\"title\"]/div[@class=\"t\"]/a/@href\').get().strip())\n                    # self.utils.sub_str_between() 是我看了 Apache 中的 StringUtils 中的方法python化一个封装的方法而已\n                    data_dict[\'商品链接\'] = \'https://detail.tmall.com/item.htm?id=\' + self.utils.sub_str_between(goods_href, \'itemid=\', \'&\') if goods_href.startswith(\'/\') else goods_href\n\n                    data_dict[\'商品价格\'] = \'\'.join(one_div.xpath(\'./div[@class=\"cost\"]/div[@class=\"p AreaPrice\"]//*/text()\').extract()).strip()\n                    data_dict[\'评论人数\'] = one_div.xpath(\'./div[@class=\"comment\"]/a/text()\').get().strip()\n                    data_dict[\'商城店铺\'] = \'\'.join(one_div.xpath(\'./div[@class=\"mall\"]\').xpath(\'p[@class=\"m\"]//*/text()|./p[@class=\"AreaZY\"]/text()\').extract()).strip()\n                    data_dict[\'最新时间\'] = one_div.xpath(\'./div[@class=\"mall\"]/p[@class=\"t\"]/text()\').get().strip()\n\n                    # 这里作数据持久化操作,这里作打印操作\n                    print(data_dict[\'商品标题\'], \'\\n\', data_dict[\'商品链接\'], \'\\n\', data_dict[\'商品价格\'], \'\\n\', data_dict[\'评论人数\'], \'\\n\', data_dict[\'商城店铺\'], \'\\n\', data_dict[\'最新时间\'], end=\'\\n\\n\')\n\n                    self.pipeline_utils.data_dict(self.name, \"慢慢买商品对比价\", data_dict, print_len_list=[10, 10, 10, 10, 10, 10])\n\n---\n\n### 步骤04:控制台输出\n\n* 我们可以看到已经成功抓取了~~\n\n  ![](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy1zaGFpbmVzLTEyNTgxOTMxMzcuY29zLmFwLWd1YW5nemhvdS5teXFjbG91ZC5jb20vJUU2JTg1JUEyJUU2JTg1JUEyJUU0JUI5JUIwJUU2JUFEJUE1JUU5JUFBJUE0MDQwMS5qcGc) \n\n---\n\n### 步骤05:持久化\n* 为了简练,代码我没贴出持久化代码,我这里做了持久化到excel文件中\n\n  ![](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy1zaGFpbmVzLTEyNTgxOTMxMzcuY29zLmFwLWd1YW5nemhvdS5teXFjbG91ZC5jb20vJUU2JTg1JUEyJUU2JTg1JUEyJUU0JUI5JUIwJUU2JUFEJUE1JUU5JUFBJUE0MDUwMS5qcGc) \n\n---\n\n### 步骤06:结束\n\n* 翻页\n\n  最后我们就可以成功抓取到数据了,但是还没翻页,如需要翻页,可以观察一下url即可\n`http://s.manmanbuy.com/Default.aspx?PageID=2&smallclass=0&ppid=0&siteid=&searchmode=0&f1=0&f2=0&f3=0&f4=0&f5=0&f6=0&price1=0&price2=0&orderby=score&iszy=0&istmall=0&zdj=0&key=%c6%bb%b9%fb8&v=&k=&min=&max=&w=&w2=&ft=&ft2=&distype=0`,有效参数是:`PageID` and `key`\n\n* 声明\n\n  在这里说明一下,数据来源于[慢慢买](http://help.manmanbuy.com/),请不要商业用途,如果有侵权,请联系我删除,我怕警察叔叔.\n\n* 题外话\n\n  就算不会写爬虫,[慢慢买](http://help.manmanbuy.com/)这个网站也为我们提供了很多便利,我们直接进该网站都可以满足很大一部分人的需求了...\n\n* 建议\n\n  大家在玩的时候建议不要玩嗨了,控制好速度,不要猛的发起请求,理解一下运维 or 反爬虫工程师的工作~~\n\n* 后续\n\n  我打算是有时间的话java化,到时候提供接口调用就方便了~ 如果有兴趣的话可以去看一下`慢慢买APP`,可以抓抓包,返回的是json数据,这里就不做介绍了~~\n\n---\n\n\n* #### 讨论\n  博客同步到 [SHY BLOG](http://shaines.cn)\n  如果你有更好的实现,联系我分享~~\n  \n  邮箱:272694308@qq.com\n\n\n\n\n', '2018-12-10 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727134201831.png', NULL, 1, 91, 1, '有一次在上课的时候看到jun19在浏览一个网站买东西(hhh),我大致看了一眼,该网站可以看到该件商品在不同商城的价格,我觉得有点意思,然后我就和他深入了解了一下该网站:(慢慢买),我就想要是爬下来,那就可以玩一下呀,然后我就找个时间写一下爬虫…', 'python,爬虫', 'python爬虫构建自己的比价系统', '20190713', 'houyu', 10);
INSERT INTO `blog` VALUES ('1150326649904996352', '1154239115950747648', 'A02_JAVA', 0, '> 之前更新了一个python爬虫的比价系统,然后最近抽找时间写了一个java版的,并且提供接口给大家调用,初衷是方便大家做一些项目可以加上一个小功能,所以请不要商业用途,提供出来的接口不可以连续频繁访问,设置了5秒限制,希望大家遵守游戏规则,如果确实需要频繁一点获取?1.代码托管到[github](https://github.com/18312097143/data-interface),clone自行提取主要功能模块整合;2.联系我针对个别 ip or user 授权访问。\n\n* 说明：\n  这次抓取的不是慢慢买的比价信息，是比比鲸的数据，为什么换了呢?实在没想到慢慢买的工程师如此简单粗暴，如果同一个IP短时间获取稍微过多,竟然封IP(20分钟左右吧,搞笑的是电脑浏览器都访问不了,这`反爬`我还真是第一见),这也是我不能忍的,想破也简单,搭一个IP池即可,之前玩python曾经搭一个IP池,但是现在java方面还没有时间同步,等有时间了写一个IP池接口那以后就方便了!\n\n* 项目坐标:\nhttps://github.com/18312097143/data-interface\n\n* 声明:\n 数据来源于比比鲸,请不要商业用途。\n\n* 接口\n  ex:http://47.107.101.121:8081/data-interface/bijia?key=荣耀10&page=1\n  说明:\n  * key 必要参数\n  * page 可选参数,default=1\n\n    正常调用:\n      ![成功调用](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy1zaGFpbmVzLTEyNTgxOTMxMzcuY29zLmFwLWd1YW5nemhvdS5teXFjbG91ZC5jb20vamF2YS1kYXRhLWludGVyZmFjZS5qcGc)\n    频繁调用: \n      ![在这里插入图片描述](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy1zaGFpbmVzLTEyNTgxOTMxMzcuY29zLmFwLWd1YW5nemhvdS5teXFjbG91ZC5jb20vamF2YS1kYXRhLWludGVyZmFjZTIuanBn)\n\n#####  讨论:\n* 博客同步到 [SHY BLOG](https:/shaines.cn)', '2018-11-26 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190720192816295.png', NULL, 1, 161, 1, '之前更新了一个python爬虫的比价系统,然后最近抽找时间写了一个java版的,并且提供接口给大家调用,初衷是方便大家做一些项目可以加上一个小功能,所以请不要商业用途,提供出来的接口不可以连续频繁访问,设置了5秒限制,希望大家遵守游戏规则,如果确实需要频繁一点获取?1.代码托管到github,clone自行提取主要功能模块整合;2.联系我针对个别 ip or user 授权访问。', 'java,爬虫', '[原创] java爬虫构建自己的比价系统', '20190713', 'houyu', 5);
INSERT INTO `blog` VALUES ('1150327044983267328', '1154239661877161984', 'A05_前端', 0, '> 折腾了几天,小程序版本 SHY BLOG V1.0.0 终于发布啦,没想到昨晚提交审核,今晚就下来了,速度还是很快的。\n\n#### 简单描述一下小程序的经过：\n\n> 大概小程序实现的功能有:\n> 首页:获取全部博客 按照 `最新` or `最热` 排序,提供`搜索`功能[点击能进入详情页面]\n> 分类:动态获取后台的`分类`设置为`栏目`,并且提供对应页面展示\n> 我的:获取用户的`用户信息`,登录暂时还没有任何功能项,登录的用于,但是还是加上了,因为后面实训需要用到多用户的角色,那就有用途了~~\n\n> 最初的梦想(设想):可以展示博客,可以查看博客,可以评论,可以点赞,那就差不多\n \n > 解析markdown用到了Towxml开源渲染库\n \n##### 01. 快速入门:看了黑马的3天小程序\n\n* 大概用了一天多一点看视频吧【使用2.3倍速观看视频快速入门。这样子有一个好处就是速度快，不浪费时间，然后还可以过度集中注意力，否则你正常倍速的话，再精彩的课程都有点犯困的】\n\n##### 02. 准备开发条件\n\n由于小程序需要https://...的接口,所以 [SHY BLOG](https://shaines.cn) 不得不加上SSL证书,在这里特别鸣谢`瑞森`好友,因为有了他花了一个好几小时进行研究了SSL证书方面的设置,后来我就站在巨人肩膀上花了10分钟就搞好了SSL,哈哈哈   团队的力量强大啊~~\n\n##### 03. 设计界面\n\n* 哈哈  ~~这个就是我周四一早起来使用 `画图` 画了一个早上的成果[捂脸]。\n\n![设计原型](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy1zaGFpbmVzLTEyNTgxOTMxMzcuY29zLmFwLWd1YW5nemhvdS5teXFjbG91ZC5jb20vJUU4JUFFJUJFJUU4JUFFJUExJUU1JThFJTlGJUU1JTlFJThCMi5wbmc)\n\n\n\n##### 04. 编写代码:\n\n* 然后就花了三天多写界面和稍微修改一下我服务器端的接口。\n\n##### 05. 稍微调整样式:\n\n* 稍微修改样式,准备一下提交审核\n\n##### 06. 审核通过(扫一扫):\n\n![小程序](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy1zaGFpbmVzLTEyNTgxOTMxMzcuY29zLmFwLWd1YW5nemhvdS5teXFjbG91ZC5jb20vJUU1JUIwJThGJUU3JUE4JThCJUU1JUJBJThGJUU3JUEwJTgxLmpwZw)\n\n\n##### 06. 发布最终效果图如下:\n\n![小程序最终效果](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy1zaGFpbmVzLTEyNTgxOTMxMzcuY29zLmFwLWd1YW5nemhvdS5teXFjbG91ZC5jb20vJUU1JUIwJThGJUU3JUE4JThCJUU1JUJBJThGJUU2JTk1JTg4JUU2JTlFJTlDJUU1JTlCJUJFLnBuZw)\n\n\n总的来说,小程序确实比较方便,直接渲染数据就可以了,界面的话,那就呵呵呵咯~~\n\n#####  讨论:\n* 博客同步到 [SHY BLOG](https:/shaines.cn)\n', '2018-12-05 00:00:00', 'https://shaines.cn/view/image?src=https://shaines.cn/static/img/applet.jpg', NULL, 1, 152, 1, '折腾了几天,小程序版本 SHY BLOG V1.0.0 终于发布啦,没想到昨晚提交审核,今晚就下来了,速度还是很快的。', '小程序', '小程序版本 SHY BLOG V1.0.0 发布啦', '20190713', 'houyu', 8);
INSERT INTO `blog` VALUES ('1150327783008804864', '1154241584416092160', 'A07_其他', 0, '> 快速评教,30秒搞定:fa-plane:\n\n[![评教啦](https://shaines.cn/view/image?src=https://files-shaines-1258193137.cos.ap-guangzhou.myqcloud.com/%E8%AF%84%E6%95%99%E5%95%A6.jpg \"评教啦\")](https://files-shaines-1258193137.cos.ap-guangzhou.myqcloud.com/%E8%AF%84%E6%95%99%E5%95%A6.jpg \"评教啦\")', '2018-12-13 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190720191659966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70', NULL, 1, 300, 1, '基于前端快速完成学校评教', '黑科技', '基于前端快速完成学校评教', '20190713', 'houyu', 1);
INSERT INTO `blog` VALUES ('1150327984637386752', '1154239115950747648', 'A02_JAVA', 0, '> java NIO的使用越来重要,找个时间学习了一下进行一下Test\n\n```java\npackage com.test2;\n\nimport org.junit.Test;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.*;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\n/**\n * @program: test01\n * @description:\n * @author: houyu\n * @create: 2019-02-24 16:17\n */\npublic class TestNIO {\n\n    /**\n     * 一、缓冲区（Buffer）：在 Java NIO 中负责数据的存取。缓冲区就是数组。用于存储不同数据类型的数据\n     *\n     * 根据数据类型不同（boolean 除外），提供了相应类型的缓冲区：\n     * ByteBuffer\n     * CharBuffer\n     * ShortBuffer\n     * IntBuffer\n     * LongBuffer\n     * FloatBuffer\n     * DoubleBuffer\n     *\n     * 上述缓冲区的管理方式几乎一致，通过 allocate() 获取缓冲区\n     *\n     * 二、缓冲区存取数据的两个核心方法：\n     * put() : 存入数据到缓冲区中\n     * get() : 获取缓冲区中的数据\n     *\n     * 三、缓冲区中的四个核心属性：\n     * capacity : 容量，表示缓冲区中最大存储数据的容量。一旦声明不能改变。\n     * limit : 界限，表示缓冲区中可以操作数据的大小。（limit 后数据不能进行读写）\n     * position : 位置，表示缓冲区中正在操作数据的位置。\n     *\n     * mark : 标记，表示记录当前 position 的位置。可以通过 reset() 恢复到 mark 的位置\n     *\n     * 0 <= mark <= position <= limit <= capacity\n     *\n     * 四、直接缓冲区与非直接缓冲区：\n     * 非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中\n     * 直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率\n     */\n\n    @Test\n    public void testByteBuffer() throws UnsupportedEncodingException {\n\n        // 1.0 新建 非直接缓冲区,并指定大小\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        // 2.0 往缓冲区put数据\n        byte[] src = \"abcde\".getBytes(\"UTF-8\");\n        byteBuffer.put(src);\n        // 3.0 缓冲区get数据\n        //      3.1 切换为读取模式,实质的意思就是byteBuffer.position()修改为0,\n        byteBuffer.flip();\n        //      3.2 新建 byte[],数据存储到byte[]\n        byte[] dst = new byte[byteBuffer.limit()];// limit():实质缓冲区可读大小\n        byteBuffer.get(dst);\n        // 4.0 输出数据\n        System.out.println(new String(dst, \"UTF-8\"));\n        // 5.0 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态\n        byteBuffer.clear();\n\n        /**\n         * 补充:\n         * byteBuffer底层实质还是一个byte[] 查看源码得知final byte[] hb;\n         * 读取之前一定需要flip():目的是使得Buffer的属性position修改为0\n         * rewind()和flip()类似,都是position修改为0可以读取\n         *\n         * 创建直接缓冲区(调用的是操作系统的内存)\n         * ByteBuffer directByteBuffer = ByteBuffer.allocateDirect(1024);\n         *\n         * 以下两行代码可以优化\n         * byte[] dst = new byte[byteBuffer.limit()];\n         * byteBuffer.get(dst);\n         *\n         * byteBuffer.array():底层是返回byte[] hb;\n         */\n    }\n\n    /**\n     * 一、通道（Channel）：用于源节点与目标节点的连接。在 Java NIO 中负责缓冲区中数据的传输。Channel 本身不存储数据，因此需要配合缓冲区进行传输。\n     *\n     * 二、通道的主要实现类\n     * 	java.nio.channels.Channel 接口：\n     * 		|--FileChannel\n     * 		|--SocketChannel\n     * 		|--ServerSocketChannel\n     * 		|--DatagramChannel\n     *\n     * 三、获取通道\n     * 1. Java 针对支持通道的类提供了 getChannel() 方法\n     * 		本地 IO：\n     * 		FileInputStream/FileOutputStream\n     * 		RandomAccessFile\n     *\n     * 		网络IO：\n     * 		Socket\n     * 		ServerSocket\n     * 		DatagramSocket\n     *\n     * 2. 在 JDK 1.7 中的 NIO.2 针对各个通道提供了静态方法 open()\n     * 3. 在 JDK 1.7 中的 NIO.2 的 Files 工具类的 newByteChannel()\n     *\n     * 四、通道之间的数据传输\n     * transferFrom()\n     * transferTo()\n     *\n     * 五、分散(Scatter)与聚集(Gather)\n     * 分散读取（Scattering Reads）：将通道中的数据分散到多个缓冲区中\n     * 聚集写入（Gathering Writes）：将多个缓冲区中的数据聚集到通道中\n     *\n     * 六、字符集：Charset\n     * 编码：字符串 -> 字节数组\n     * 解码：字节数组  -> 字符串\n     *\n     */\n    @Test\n    public void testChannelByFileInputStream() throws IOException {\n\n        // 1.0 获取文件输入流\n        FileInputStream inputStream = new FileInputStream(\"D:/1.txt\");\n        // 2.0 文件输入流获取通道\n        FileChannel fileChannel = inputStream.getChannel();\n        // 3.0 读取文件信息\n        //      3.1 创建非直接缓冲区\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n        while (fileChannel.read(dst) != -1){// 管道循环读取文件到缓冲区\n            dst.flip();// 读取文件必须要切换为读取模式\n            String tempString = new String(dst.array(), \"GBK\");\n            System.out.println(tempString);// window默认编码为GBK,否则乱码\n        }\n        // 4.0 关闭资源\n        fileChannel.close();\n        inputStream.close();\n\n    }\n\n    /**\n     * 通过缓冲区复制文件\n     */\n    @Test\n    public void testChannelTOCopyFile_1() throws IOException {\n\n        // 1.0 获取流\n        FileInputStream inputStream = new FileInputStream(\"D:/1.txt\");\n        FileOutputStream outputStream = new FileOutputStream(\"D:/2.txt\");\n        // 2.0 流获取通道\n        FileChannel inChannel = inputStream.getChannel();\n        FileChannel outChannel = outputStream.getChannel();\n        // 3.0 创建非直接缓冲区\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        // 4.0 inChannel读取文件到缓冲区并写入到outChannel\n        while (inChannel.read(byteBuffer) != -1){\n            byteBuffer.flip();\n            outChannel.write(byteBuffer);\n            byteBuffer.clear();\n        }\n        // 5.0 关闭资源\n        outChannel.close();\n        inputStream.close();\n        outChannel.close();\n        inputStream.close();\n        /**\n         * 补充:\n         *      这种复制文件使用的非直接缓冲区,速度方面比不上使用直接缓冲区\n         */\n    }\n\n    /**\n     * 通过内存映射文件复制文件\n     */\n    @Test\n    public void testChannelTOCopyFile_2() throws IOException {\n        // 使用FileChannel静态方法open()获取通道\n        FileChannel inChannel = FileChannel.open(Paths.get(\"D:/1.pdf\"), StandardOpenOption.READ);\n        FileChannel outChannel = FileChannel.open(Paths.get(\"D:/2.pdf\"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);\n        // 获取内存映射文件\n        MappedByteBuffer inMappedBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());\n        MappedByteBuffer outMappedBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());\n        // 直接对缓冲区进行数据的读写操作\n        byte[] dst = new byte[inMappedBuffer.limit()];\n        inMappedBuffer.get(dst);\n        outMappedBuffer.put(dst);\n        // 关闭资源\n        outMappedBuffer.clear();\n        inMappedBuffer.clear();\n        outChannel.close();\n        inChannel.close();\n\n    }\n\n    /**\n     * 通过管道对管道复制文件\n     */\n    @Test\n    public void testChannelTOCopyFile_3() throws IOException {\n        // 1.0 使用FileChannel静态方法open()获取通道\n        FileChannel inChannel = FileChannel.open(Paths.get(\"D:/1.pdf\"), StandardOpenOption.READ);\n        FileChannel outChannel = FileChannel.open(Paths.get(\"D:/2.pdf\"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);\n        // 2.0 管道对接管道\n        inChannel.transferTo(0, inChannel.size(), outChannel);\n        // outChannel.transferFrom(inChannel, 0, inChannel.size());\n        // 3.0 关闭资源\n        inChannel.close();\n        outChannel.close();\n    }\n\n    /**\n     * 分散和聚集\n     */\n    @Test\n    public void testScatterAndGather() throws IOException {\n        // 1.0 创建随机访问文件对象\n        RandomAccessFile randomAccessFile = new RandomAccessFile(\"D:/1.txt\", \"rw\");\n        // 2.0 获取管道\n        FileChannel inChannel = randomAccessFile.getChannel();\n        // 3.0 创建指定大小的缓冲区\n        ByteBuffer buf1 = ByteBuffer.allocate(50);\n        ByteBuffer buf2 = ByteBuffer.allocate(1024);\n        ByteBuffer[] bufs = {buf1, buf2};\n        inChannel.read(bufs);\n        // 4.0 切换读模式\n        buf1.flip();\n        buf2.flip();\n        // 5.0 输出查看效果\n        System.out.println(new String(buf1.array()));\n        System.out.println(\"-----------------\");\n        System.out.println(new String(buf2.array()));\n        // 6.0 创建输出随机访问对象\n        RandomAccessFile outFile = new RandomAccessFile(\"D:/2.txt\", \"rw\");\n        // 7.0 获取管道\n        FileChannel outChannel = outFile.getChannel();\n        outChannel.write(bufs);\n\n        // 8.0 关闭资源\n        outChannel.close();\n        outFile.close();\n        buf2.clear();\n        buf1.clear();\n        inChannel.close();\n        randomAccessFile.close();\n\n    }\n\n    //字符集\n    @Test\n    public void testCharset() throws IOException{\n        Charset cs1 = Charset.forName(\"GBK\");\n        //获取编码器\n        CharsetEncoder ce = cs1.newEncoder();\n        //获取解码器\n        CharsetDecoder cd = cs1.newDecoder();\n        CharBuffer cBuf = CharBuffer.allocate(1024);\n        cBuf.put(\"我是数据\");\n        cBuf.flip();\n        //编码\n        ByteBuffer bBuf = ce.encode(cBuf);\n        for (int i = 0; i < 8; i++) {\n            System.out.println(bBuf.get());\n        }\n        //解码\n        bBuf.flip();\n        CharBuffer cBuf2 = cd.decode(bBuf);\n        System.out.println(cBuf2.toString());\n    }\n\n    /*\n     * 一、使用 NIO 完成网络通信的三个核心：\n     *\n     * 1. 通道（Channel）：负责连接\n     *\n     * 	   java.nio.channels.Channel 接口：\n     * 			|--SelectableChannel\n     * 				|--SocketChannel\n     * 				|--ServerSocketChannel\n     * 				|--DatagramChannel\n     *\n     * 				|--Pipe.SinkChannel\n     * 				|--Pipe.SourceChannel\n     *\n     * 2. 缓冲区（Buffer）：负责数据的存取\n     *\n     * 3. 选择器（Selector）：是 SelectableChannel 的多路复用器。用于监控 SelectableChannel 的 IO 状况\n     *\n     */\n    //客户端\n    @Test\n    public void testBlockingNIOClient_1() throws IOException{\n        //1. 获取通道\n        SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 9898));\n        FileChannel inChannel = FileChannel.open(Paths.get(\"D:/1.txt\"), StandardOpenOption.READ);\n        //2. 分配指定大小的缓冲区\n        ByteBuffer buf = ByteBuffer.allocate(1024);\n        //3. 读取本地文件，并发送到服务端\n        while(inChannel.read(buf) != -1){\n            buf.flip();\n            sChannel.write(buf);\n            buf.clear();\n        }\n        //4. 关闭通道\n        inChannel.close();\n        sChannel.close();\n    }\n\n    //服务端\n    @Test\n    public void testBlockingNIOServer_1() throws IOException{\n        //1. 获取通道\n        ServerSocketChannel ssChannel = ServerSocketChannel.open();\n        FileChannel outChannel = FileChannel.open(Paths.get(\"D:/2.txt\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        //2. 绑定连接\n        ssChannel.bind(new InetSocketAddress(9898));\n        //3. 获取客户端连接的通道\n        SocketChannel sChannel = ssChannel.accept();\n        //4. 分配指定大小的缓冲区\n        ByteBuffer buf = ByteBuffer.allocate(1024);\n        //5. 接收客户端的数据，并保存到本地\n        while(sChannel.read(buf) != -1){\n            buf.flip();\n            outChannel.write(buf);\n            buf.clear();\n        }\n        //6. 关闭通道\n        sChannel.close();\n        outChannel.close();\n        ssChannel.close();\n    }\n\n    //客户端\n    @Test\n    public void testBlockingNIOClient_2() throws IOException{\n        SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 9898));\n        FileChannel inChannel = FileChannel.open(Paths.get(\"1.jpg\"), StandardOpenOption.READ);\n        ByteBuffer buf = ByteBuffer.allocate(1024);\n        while(inChannel.read(buf) != -1){\n            buf.flip();\n            sChannel.write(buf);\n            buf.clear();\n        }\n        sChannel.shutdownOutput();\n        //接收服务端的反馈\n        int len;\n        while((len = sChannel.read(buf)) != -1){\n            buf.flip();\n            System.out.println(new String(buf.array(), 0, len));\n            buf.clear();\n        }\n\n        inChannel.close();\n        sChannel.close();\n    }\n\n    //服务端\n    @Test\n    public void testBlockingNIOServer_2() throws IOException{\n        ServerSocketChannel ssChannel = ServerSocketChannel.open();\n        ssChannel.bind(new InetSocketAddress(9898));\n        FileChannel outChannel = FileChannel.open(Paths.get(\"2.jpg\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        SocketChannel sChannel = ssChannel.accept();\n        ByteBuffer buf = ByteBuffer.allocate(1024);\n        while(sChannel.read(buf) != -1){\n            buf.flip();\n            outChannel.write(buf);\n            buf.clear();\n        }\n        //发送反馈给客户端\n        buf.put(\"服务端接收数据成功\".getBytes());\n        buf.flip();\n        sChannel.write(buf);\n        sChannel.close();\n        outChannel.close();\n        ssChannel.close();\n    }\n\n\n    //客户端\n    @Test\n    public void testNonBlockingNIOClient_1() throws IOException{\n        //1. 获取通道\n        SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 9898));\n        //2. 切换非阻塞模式\n        sChannel.configureBlocking(false);\n        //3. 分配指定大小的缓冲区\n        ByteBuffer buf = ByteBuffer.allocate(1024);\n        //4. 发送数据给服务端\n        Scanner scan = new Scanner(System.in);\n        while(scan.hasNext()){\n            String str = scan.next();\n            buf.put((new Date().toString() + \"\\n\" + str).getBytes());\n            buf.flip();\n            sChannel.write(buf);\n            buf.clear();\n        }\n        //5. 关闭通道\n        sChannel.close();\n    }\n\n    //服务端\n    @Test\n    public void testNonBlockingNIOServer_1() throws IOException{\n        //1. 获取通道\n        ServerSocketChannel ssChannel = ServerSocketChannel.open();\n        //2. 切换非阻塞模式\n        ssChannel.configureBlocking(false);\n        //3. 绑定连接\n        ssChannel.bind(new InetSocketAddress(9898));\n        //4. 获取选择器\n        Selector selector = Selector.open();\n        //5. 将通道注册到选择器上, 并且指定“监听接收事件”\n        ssChannel.register(selector, SelectionKey.OP_ACCEPT);\n        //6. 轮询式的获取选择器上已经“准备就绪”的事件\n        while(selector.select() > 0){// 这个方法是阻塞的\n            //7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”\n            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n            while(it.hasNext()){\n                //8. 获取准备“就绪”的是事件\n                SelectionKey sk = it.next();\n                //9. 判断具体是什么事件准备就绪\n                if(sk.isAcceptable()){\n                    //10. 若“接收就绪”，获取客户端连接\n                    SocketChannel sChannel = ssChannel.accept();\n                    //11. 切换非阻塞模式\n                    sChannel.configureBlocking(false);\n                    //12. 将该通道注册到选择器上\n                    sChannel.register(selector, SelectionKey.OP_READ);\n                }else if(sk.isReadable()){\n                    //13. 获取当前选择器上“读就绪”状态的通道\n                    SocketChannel sChannel = (SocketChannel) sk.channel();\n                    //14. 读取数据\n                    ByteBuffer buf = ByteBuffer.allocate(1024);\n                    int len = 0;\n                    while((len = sChannel.read(buf)) > 0 ){\n                        buf.flip();\n                        System.out.println(new String(buf.array(), 0, len));\n                        buf.clear();\n                    }\n                }\n                //15. 取消选择键 SelectionKey\n                it.remove();\n            }\n        }\n    }\n\n\n\n    @Test\n    public void testNonBlockingNIOSend_2() throws IOException{\n        DatagramChannel dc = DatagramChannel.open();\n        dc.configureBlocking(false);\n        ByteBuffer buf = ByteBuffer.allocate(1024);\n        Scanner scan = new Scanner(System.in);\n        while(scan.hasNext()){\n            String str = scan.next();\n            buf.put((new Date().toString() + \":\\n\" + str).getBytes());\n            buf.flip();\n            dc.send(buf, new InetSocketAddress(\"127.0.0.1\", 9898));\n            buf.clear();\n        }\n        dc.close();\n    }\n\n    @Test\n    public void testNonBlockingNIOReceive_2() throws IOException{\n        DatagramChannel dc = DatagramChannel.open();\n        dc.configureBlocking(false);\n        dc.bind(new InetSocketAddress(9898));\n        Selector selector = Selector.open();\n        dc.register(selector, SelectionKey.OP_READ);\n        while(selector.select() > 0){\n            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n            while(it.hasNext()){\n                SelectionKey sk = it.next();\n                if(sk.isReadable()){\n                    ByteBuffer buf = ByteBuffer.allocate(1024);\n                    dc.receive(buf);\n                    buf.flip();\n                    System.out.println(new String(buf.array(), 0, buf.limit()));\n                    buf.clear();\n                }\n            }\n            it.remove();\n        }\n    }\n\n\n    @Test\n    public void testPipe() throws IOException{\n        //1. 获取管道\n        Pipe pipe = Pipe.open();\n        //2. 将缓冲区中的数据写入管道\n        ByteBuffer buf = ByteBuffer.allocate(1024);\n        Pipe.SinkChannel sinkChannel = pipe.sink();\n        buf.put(\"通过单向管道发送数据\".getBytes());\n        buf.flip();\n        sinkChannel.write(buf);\n        //3. 读取缓冲区中的数据\n        Pipe.SourceChannel sourceChannel = pipe.source();\n        buf.flip();\n        int len = sourceChannel.read(buf);\n        System.out.println(new String(buf.array(), 0, len));\n        sourceChannel.close();\n        sinkChannel.close();\n    }\n\n\n}\n\n```\n', '2019-02-24 00:00:00', 'https://shaines.cn/view/image?src=https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/bLmy0N4HIaeAkta2SLAPiaueficQCvVMNOGC17995peA68nicv9REHEpicmdhRLwq0DBibUNCy4zyvKB8mB7ONXdrOw/640?wx_fmt=jpeg', NULL, 1, 97, 1, 'java NIO', 'java,基础,NIO', '初始java NIO', '20190713', 'houyu', 1);
INSERT INTO `blog` VALUES ('1150329747008430080', '1154241584416092160', 'A07_其他', 0, '> TeamViewer只要被检测为商业用途，哪怕是卸载重装，也是依旧被提示的，所以就简单介绍一下我的实操；\n> 我也有一段时间没有使用TeamViewer了,但是最近几次使用我竟然被提示商业用途，这就让我很不爽了，这样子的话有时候会耽误事的呀，所以昨晚我就尝试寻找解决方案，找了很久，测试了很多方式才算暂时解决。查看了很多文章都是叫卸载，删除注册表等操作，但是这些文章都是有一定历史了，对于TeamViewer12以上版本早就不适用了...\n\n## 解决方案\n\n - [ ] 购买正版（金额未了解）（富豪推荐）\n - [ ] 某宝购买破解（15-30不等）（土豪推荐）\n - [x] 伪绿化破解\n\n**傻瓜式按部就班解决方案**  我个人就比较喜欢这样子的方式[捂脸]\n\n## 步骤01：卸载TeamViewer\n ![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190302110243555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190302110509634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n\n## 步骤02：删除相关注册表\n运行命令对话框：Ctrl+R，输入命令：regedit，点击确定\n\n按照以下步骤：while(true){**编辑 => 查找 => 查找目标 => 项 => 查找下一个**}\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190302113255180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n这个方法才是删除相关注册表最实在有效的方法，你会发现找到好几个TeamViewer相关的注册表，右键删除即可\n\n## 步骤03：修改MAC(物理地址)\n所有步骤按照以下图操作即可\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190302121608972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n## 步骤04：重启电脑\n确保MAC地址更新成功\n\n## 步骤05：重新安装TeamViewer\n去官网下载安装包,然后安装即可!\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190302115729441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n安装使用，你就发现没有了烦人的商业用途提示了，哇卡卡卡。。。\n\n## 结束语\n1. 目前来说这个是比较新详细且有用的教程了，祝你好运；\n2. 这里涉及了删除相关注册表，同理以后你需要删除干净某注册表使用该方法最有效；\n3. 这里涉及了修改MAC地址，以后需要修改MAC就按照上面操作就方便了；\n4. 这个方法同样适用于其他收费软件或者免费体验的软件破解（伪绿化）;\n\n\n如果你动手能力一般，建议直接某宝购买即可，方便省事，我之前也购买过，但是发现TeamViewer版本更新速度有点快，即便是某宝的破解也跟不上速度，如果一直使用低版本的破解也会经常卡顿。这个也是写这个博客的初衷，希望对你有所帮助！\n\n\n\n\n\n', '2019-03-14 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727134148931.png', NULL, 1, 126, 1, 'TeamViewer是一个多平台的桌面远程软件，相信很多人的使用过，但是有一个问题就是容易个人用途被检测到为商业用途，这就比较闹心了，因为只要检测到商业用途，那就会被限制，每次连接只能5分钟，并且经常连接失败，那么如何解决呢？', '黑科技', 'TeamViewer14检测为商业用途最优解', '20190713', 'houyu', 3);
INSERT INTO `blog` VALUES ('1150330220230778880', '1154239115950747648', 'A02_JAVA', 0, '> JDK的动态代理实现的原理其实是动态生成Proxy的.java文件，再动态编译.java文件成为对应的.class文件，再通过ClassLoader将字节码对象加载到内存中从而实现动态的效果。现在主要是测试一下如何使用JDK的动态代理，不做原理的分析。如果想了解原理可以观看`马士兵的设计模式之动态代理`深入剖析。\n\n```java\npackage cn.shaines.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * 定义一个接口\n */\ninterface MyInterface {\n    int getInt(int i);\n    void close();\n}\n\n/**\n * 接口实现类\n */\nclass MyInterfaceImpl implements MyInterface {\n    @Override\n    public int getInt(int i) {\n        return i;\n    }\n    @Override\n    public void close() {\n        System.out.println(\"==>>close()\");\n    }\n\n    public void otherMethod(){\n        System.out.println(\"==>>otherMethod()\");\n    }\n}\n\n/**\n * 测试类JDK代理\n */\npublic class Test {\n\n    /**\n     * 反射执行方法\n     * @param o 调用对象\n     * @param methodName 方法名称\n     * @param parameterTypes 参数类型.class\n     * @param parameters 参数实体\n     */\n    public static <R> R methodInvoke(Object o, String methodName, Class<?>[] parameterTypes, Object[] parameters) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        return (R) ((parameterTypes == null) ? o.getClass().getMethod(methodName).invoke(o) : o.getClass().getMethod(methodName, parameterTypes).invoke(o, parameters));\n    }\n\n    // 入口main\n    public static void main(String[] args) {\n\n        // 使用JDK提供的动态代理方法步骤如下:\n        // 步骤01: 创建需要代理的实体类对象\n        MyInterfaceImpl myInterfaceImpl = new MyInterfaceImpl();\n        // 步骤02: 获取实体类对象的Class对象\n        Class<? extends MyInterfaceImpl> clazz = myInterfaceImpl.getClass();\n        // 步骤03: 调用JDK提供的Proxy.newProxyInstance()方法\n        Object proxyInstance = Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                // 步骤04: 动态修改getInt()方法\n                if (method.getName().equals(\"getInt\")){\n                    System.out.println(\"代理类收到的参数是:\" + args[0]);\n                    return 100;\n                }\n                // 步骤05: 注意这里的实际调用必须是实现类对象\n                return method.invoke(myInterfaceImpl);\n            }\n        });\n\n        // cn.shaines.test.MyInterfaceImpl\n        System.out.println(clazz.getClass().getName());\n        // java.lang.Class\n        System.out.println(clazz.getName());\n\n        // 步骤06: 使用代理对象(强制转换为接口对象MyInterface,不可以强制转换为MyInterfaceImpl,\n        //         通过上面的打印可以知道proxyInstance的class和MyInterfaceImpl的class是不同的,强制转换会报错)\n        // MyInterfaceImpl myInterfaceImpl2 = ((MyInterfaceImpl) proxyInstance);// 报错\n        MyInterface myInterface1 = ((MyInterface) proxyInstance);\n        int anInt = myInterface1.getInt(20);\n        System.out.println(\"anInt:\" + anInt);// anInt:100     被动态修改值\n        myInterface1.close();\n\n        // 放射执行方法,无需强制转为对象都可以使用proxyInstance调用任意方法\n        try {\n            int i = methodInvoke(proxyInstance, \"getInt\", new Class[]{int.class}, new Object[]{10});\n            methodInvoke(proxyInstance, \"close\", new Class[]{}, new Object[]{});\n            // methodInvoke(proxyInstance, \"otherMethod\", new Class[]{}, new Object[]{});\n            // 这个方法会报错:java.lang.NoSuchMethodException: cn.shaines.test.$Proxy0.otherMethod()\n            // 找不到该方法,原因很简单,该动态代理对象是实现接口(MyInterface),不是继承接口实现类(MyInterfaceImpl),所以只有接口的方法,没有具体实现对象(myInterfaceImpl)的方法\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n\n```', '2019-03-04 00:00:00', 'https://shaines.cn/view/image?src=https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/bLmy0N4HIaeAkta2SLAPiaueficQCvVMNOrHp4zm7QADLiawjxnvtRmIaAGlERMuAYGTH1QYkGerYPeSLE9Ck3qSA/640?wx_fmt=jpeg', NULL, 1, 97, 1, 'JDK的动态代理实现的原理其实是动态生成Proxy的.java文件，再动态编译.java文件成为对应的.class文件，再通过ClassLoader将字节码对象加载到内存中从而实现动态的效果。现在主要是测试一下如何使用JDK的动态代理，不做原理的分析。如果想了解原理可以观看马士兵的设计模式之动态代理深入剖析。', 'java,基础', '简单使用JDK的Proxy.newProxyInstance()方法', '20190713', 'houyu', 2);
INSERT INTO `blog` VALUES ('1150331074652446720', '1154239164080386048', 'A03_PYTHON', 0, '> （貌似我当初记得开通微信支付需要年费，不知道现在什么情况了哈）给微信支付也可以简单实现一下，首先想到了监听微信信息，因为二维码收款收到钱微信会显示一个收款信息，所以打算从这个入手，然后我略懂一些爬虫，天真的我想去微信抓包，结果发现抓包没问题，解密才是大头[奸笑]，查询了很多资料，都没有很多介绍，然后我就突发奇想python有没有这个微信模块呢？（我也去了解java，代码成吨成吨的，何必用大炮打蚊子呢，真不是黑，我也是java粉哈）结果发现了好几个python模块[奸笑]，等有时间了再去深入了解吧，现在先上一个比较好玩的模块wxpy实现【伪】人工智能机器猫。\n\n#### 话不多少了，先看一下效果吧【奸笑】\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190306221202632.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n接下来就是代码啦【据说下面的12行核心AI代码价值一个亿】\n\n```python\nfrom wxpy import *\nfrom random import choice\n\nbot = Bot(cache_path=True)\n\n# 笑话大全\njoke_lists = [\'经理：“小杨，你早晨上班迟到了，下班又早退，不太合适吧?”小杨：“经理，现在路况不好，总是堵车.我上班迟到了，下班回家就不能再迟到了，否则，我还要被老婆批评的.”\',\n              \'重庆江北北宾路，一酒驾司机被交警拦下.就在他下车一瞬间，这哥们抄起瓶五粮液，一扬脖就喝了半瓶.然后边喝边说，“我不是酒后驾车，我是驾后喝酒.现在我喝了酒，不能开车了，不然要拘6个月.我车就停这，乱停车你们开罚单，拖走也行.我打车走了，明再来提车”.交警茫然...\',\n              \'一次我和几个朋友去商场逛，逛着逛着决定坐电梯到楼上接着逛，在一个很偏僻的电梯口等了一会发现这个电梯是残疾人专用的，然后我一姐们很牛x的说：没事，咱们是脑残\',\n              \'一日上课，闲来无事，在课桌上写下：“孤枕难眠”翌日，竟然看多了几个字：“换个两枕头试试。”\',\n              \'耳朵发炎去医院买了点药，刚刚找个位置坐下来用棉签掏耳朵，结果一熊孩子过来说到：叔叔，你是在找你的金箍棒吗？\',\n              \'有一次到国外旅游，我们走进一家挂满漂亮衣服的服装店我们随意试穿着衣服。两个店员却以古怪的眼神盯着我们，使我们感到很不自在。终于，一位会讲汉语的店员实在看不下去了她悄悄地向我们解释：“对不起，我们这是一家干洗店。\'\n              ]\n\n@bot.register(except_self=False, msg_types=TEXT) # 不过滤自身\ndef print_others(msg):\n    text = msg.text\n    # 你好\n    # 你叫什么?\n    # 你会唱歌吗?\n    # 你喜欢谁?\n    # 你给我讲一个笑话吧\n    # 这个笑话不好笑,再来一个吧\n    # 你知道1+1等于多少吗?\n    if text.__contains__(\'你叫\'):\n        return (\'我叫wxpy机器猫\')\n    elif text.__contains__(\'吗\') and text.__contains__(\'你\'):\n        return (text.replace(\'你\', \'我\').replace(\'吗\', \'呀\').replace(\'？\', \'!\'))\n    elif text.__contains__(\'你好\'):\n        return (\'你好!\')\n    elif text.__contains__(\'喜欢谁\'):\n        return (\'我喜欢你呀!\')\n    elif text.__contains__(\'笑话\'):\n        return (choice(joke_lists))\n    else:\n        return (\'我还不能理解你说什么哟,请找我的主人吧[捂脸]\')\n\nembed()\n```\n\n## 实现:\n\n -  ### 步骤01:安装wxpy模块\n	pip install wxpy\n\n -  ### 步骤02:查看官网文档\n	 [wxpy: 用 Python 玩微信](https://wxpy.readthedocs.io/zh/latest/index.html)（中文的）\n	 or\n	 查看相关博客[快速案例](https://www.jianshu.com/p/577129b32756)\n\n -  ### 步骤03:实现自己的逻辑\n 	了解一定后，就看你怎么玩了【奸笑】\n\n\n## 结束语：\nwxpy这个模块很强大哦，可以使用做什么？我大概想到了有以下：\n\n - 智能客服【当然你不会写上面一个亿的代码啦】\n - 简易版微信支付【我大概逻辑写好了，等有时间更新，到时候做成一个小开源接口，那样子任何开发者都可以玩微信支付了，主要是不用交钱，哈哈哈哈哈....】\n - 广告助手\n - 刷票助手\n - 点赞助手\n - 公众号点广告助手\n - 批量添加好友助手\n - ......\n\n当然还有很多用法，就看大家怎么玩，想象力在哪了【奸笑】，我也是刚了解到，接触不深，很多功能我也还不了解，分享一下。\n\n如果你有了解这个模块，或者你有更好玩的，欢迎留言交流哦。\n\n交流: qqmail：\n	for.houyu.@qq.com\n	272694308@qq.com\n\n\n博客同步到[shaines.cn](https://www.shaines.cn)', '2019-03-09 00:00:00', 'https://shaines.cn/view/image?src=https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=83f413f4d7c451daf6f60bed8ec6355b/3b87e950352ac65c8819edd9f1f2b21193138a78.jpg', NULL, 1, 364, 1, '先说一下我是怎么了解到这个wxpy模块的：\n首先说明一下我是业余py爱好者，一开始确实是不知道这个流弊的模块，我是想突然想搞一个微信支付的微服务供其他模块调用，之前（好久好久了吧）去了解微信支付和支付宝支付的时候需要很多条件才可以申请，然后使用测试账号，当时又没有服务器[捂脸]，搞不了回调，所以一直没有搞成，等买了服务器，又没有实际的需求趋势我继续了解这两个支付了，所以一直没有搞。最近突然想起这事，我在想能不能不交300块', 'python', '初识python wxpy模块之人工智能机器猫', '20190713', 'houyu', 10);
INSERT INTO `blog` VALUES ('1150331897260318720', '1154239164080386048', 'A03_PYTHON', 0, '> 测试花了不少时间，只要是我想在服务器上跑这个wxpy项目，所以需要在我的服务器上搭python环境，折腾了不少时间，乱码这种问题等，然后又在tomcat上部署一个small【simple mall】项目（目标是做成类似自动发卡系统，现在还在筹划中...页面怎么写【捂脸】有点愁啊）。目前这个small只是完成了支付模块，尚未成型...\n\n**先看效果swxpay【simple wxpay:简易微信支付】**\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190309130157561.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n <a href=\'https://shaines.cn/small/testwxpay\' target=\"_blank\"><span style=\"font-size=32\">前往测试体验<span></a>\n\n> 设置了0.5元测试接口的支付金额，实际使用可以自行设定即可\n\n### 简单介绍一下swxpay优缺点:\n\n#### 优点:\n\n *  （1）摆脱申请微信支付繁琐的步骤\n 	- （a）在线提交营业执照、身份证、银行账户等基本信息，并按指引完成账户验证\n 	- （b）微信支付团队会在1-2个工作日内完成审核，审核通过后请在线签约，即可体验各项产品能力\n 	- （c）如需自行开发完成收款，需将商户号与APPID进行绑定，或开通微信收款商业版（免开发）完成收款\n\n* （2）方便个人网站接入微信支付\n* （3）支持回调个人网站的第三方接口\n* （4）0基础实现支付开发，摆脱微信支付学习成本\n\n \n#### 缺点:\n* （1）可能无法支撑大规模支付\n    -  （a）可以优化提高\n* （2）需要使用一个小号进行绑定二维码收款\n	-  （a）原理的局限性决定的，是登录网页版微信监听实现消息实现\n*  （3）服务端需要生成唯一ID传递给支付用户从而确定支付的目标订单\n	-  （a）通过支付备注传递\n* 需要一定的python知识\n 	-  非必须，因为我都写好了，贴出来即可【奸笑】\n\n\n##### 话不多说看代码实现吧...\n\n```python\n\nimport datetime\nimport time\nimport pymysql\nimport requests\nfrom DBUtils.SimplePooledDB import PooledDB\nfrom wxpy import *\n\nclass DaoUtil:\n    def __init__(self):\n        self.__pool = PooledDB(pymysql, 3, host=\'localhost\', port=3306, user=\'root\', passwd=\'123456\', db=\'small\', cursorclass = pymysql.cursors.DictCursor)\n\n    def __get_connection(self):\n        connection = self.__pool.connection()\n        return connection\n\n    def execute_sql(self, sql, is_return=False):\n        connection = self.__get_connection()\n        result = None\n        try:\n            cursor = connection.cursor() # as_dict=True\n            cursor.execute(sql)\n            if is_return:\n                result = cursor.fetchall()\n            else:\n                result = True\n            connection.commit()\n        except Exception as e:\n            print(e)\n            # write log db\n        finally:\n            cursor.close()\n            connection.close()\n            return result\n\n# ---------------------------------------------------------------------------------------------------------- #\n\n_payid_start_str = \'付款方备注\'\n_payid_start_str_len = len(_payid_start_str)\n_payid_end_str = \'汇总\'\n\n_money_start_str = \'收款\'\n_money_start_str_len = len(_money_start_str)\n_money_end_str = \'元\'\n\ndaoUtil = DaoUtil()\n\n_default_headers = {\n            \'Accept\': \"*/*\",\n            \'Accept-Language\': \"zh-CN,zh;q=0.8\",\n            \'Accept-Encoding\': \'gzip, deflate\',\n            \'Connection\': \'keep-alive\',\n            \'Referer\': \'https://www.baidu.com\',\n            \'User-Agent\': \'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36\',\n            \'Upgrade-Insecure-Requests\': \'1\',\n        }\n\n# bot = Bot(cache_path=True)\nbot = Bot(console_qr=2, cache_path=True, qr_path=\'/www/server/shainesfiles/python_wx/login.png\')\n\n# @bot.register(msg_types=TEXT)\n@bot.register(msg_types = SHARING)\ndef process_mp_wxpay(msg):\n    # 只获取微信支付公众号的信息\n    if str(msg.sender) == \'<MP: 微信支付>\':\n        err_msg = \'\'\n\n        raw = msg.raw\n        # 获取消息id\n        _id = raw[\'MsgId\']\n        # print(\'id:\', _id)\n\n        # 获取付款id\n        _content = str(raw[\'Content\'])\n        payid = get_payid(_content)\n        # print(\'payid:\', payid)\n\n        # 获取金额\n        _text = str(msg.text)\n        money = get_money(_text)\n        if money == 0.0:\n            err_msg += \' 获取金额失败\'\n        # print(\'money:\', money)\n\n        # 获取微信服务器收款时间\n        createtime = str(msg.create_time)\n        createtime = date_str_to_time_second(date_str = createtime)\n        if createtime == 0:\n            err_msg += \' 获取微信服务器创建时间失败\'\n        # print(\'createtime:\', createtime)\n\n        # 获取本地程序收款时间\n        receivetime = str(msg.receive_time)\n        receivetime = receivetime[0: str(receivetime).rfind(\'.\')]\n        receivetime = date_str_to_time_second(date_str = receivetime)\n        if createtime == 0:\n            err_msg += \' 获取本地接受时间失败\'\n        # print(\'receivetime:\', receivetime)\n\n        latency = msg.latency\n        latency = str(latency)\n        if len(latency) > 8:\n            latency = latency[0: 8]\n        latency = float(latency)\n        # print(\'latency:\', latency)\n\n        sql = f\"INSERT INTO wxpay (id, payid, money, createtime, receivetime, latency, remarks) VALUES (\'{_id}\', \'{payid}\', {money}, {createtime}, {receivetime}, {latency}, \'{err_msg}\')\"\n\n        # print(sql)\n        daoUtil.execute_sql(sql)\n\n        # 网络请求调用接口\n        # requests.request(\'post\', url=url, data=data, json=json, headers=_default_headers, timeout=timeout)\n\n# ---------------------------------------------------------------------------------------------------------- #\n\ndef date_str_to_time_second(date_str=\'2018-08-18 09:16:36\', format=\'%Y-%m-%d %H:%M:%S\'):\n    \'\'\'\n    时间字符串转毫秒值\n    \'\'\'\n    _time_second = 0\n    try:\n        date_time_obj = datetime.datetime.strptime(date_str, format)\n        _time_second = int(time.mktime(date_time_obj.timetuple()) * 1000)\n    except:\n        _time_second = 0\n    return _time_second\n\ndef get_money(_text):\n    \'\'\'\n    解析获取money\n    \'\'\'\n    _money_start_index = _text.find(_money_start_str)\n    _money_end_index = _text.find(_money_end_str, _money_start_index)\n    money = 0.0\n    try:\n        money = float(_text[_money_start_index + _money_start_str_len: _money_end_index])\n    except:\n        money = 0.0\n    return money\n\n\ndef get_payid(_content):\n    \'\'\'\n    解析获取支付id\n    \'\'\'\n    _payid_start_index = _content.find(_payid_start_str)\n    _payid_end_index = _content.find(_payid_end_str, _payid_start_index)\n    # payid = 0\n    # try:\n    #     payid = int(str(_content[_payid_start_index + _payid_start_str_len: _payid_end_index]).strip())\n    # except:\n    #     payid = 0\n    # return payid\n    return str(_content[_payid_start_index + _payid_start_str_len: _payid_end_index]).strip()\n\n# ---------------------------------------------------------------------------------------------------------- #\n\nembed()\n\n```\n\n### 结束语\n\n - 目前代码实现也就是160行左右，现在只是测试阶段，有可能还需要根据具体使用修改部分代码\n - 如果你有一定python基础的话可以拿去跑一下，但是提前告知你，肯定会有一系列问题，部署到服务器上问题测试更多的了...\n - 如果有时间的话下一篇博客有可以能会介绍如何在window and linux 服务器上部署swxpay（Simple wxpay）\n \n博客同步到[SHY BLOG](https://shaines.cn/u/shy/blogs/20)\n\n![此代码无BUG](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLnVjLmNuL28vd2VtZWRpYS9zL3VwbG9hZC8yMDE4LzAyMTg5NGZhNjA4YzUwMjk2ZDlhZjY1YzM5NjUxMjhkeDY0NHg3NjJ4NTEuanBlZzssMyxqcGVneDszLDcwMHguanBn)\n', '2019-03-06 00:00:00', 'https://shaines.cn/view/image?src=https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=83f413f4d7c451daf6f60bed8ec6355b/3b87e950352ac65c8819edd9f1f2b21193138a78.jpg', NULL, 1, 357, 1, '测试花了不少时间，只要是我想在服务器上跑这个wxpy项目，所以需要在我的服务器上搭python环境，折腾了不少时间，乱码这种问题等，然后又在tomcat上部署一个small【simple mall】项目（目标是做成类似自动发卡系统，现在还在筹划中…页面怎么写【捂脸】有点愁啊）。目前这个small只是完成了支付模块，尚未成型…', 'python', '初识python wxpy模块之swxpay[简易版微信支付]', '20190713', 'houyu', 2);
INSERT INTO `blog` VALUES ('1150332877313974272', '1154239115950747648', 'A02_JAVA', 0, '> 前几天搞了一个文件管理系统，因为几乎做每一个项目都涉及到上传文件这一步骤，不可能每一个项目都做一个模块处理文件，所以我最近整了一个小文件系统来用，这样子别的项目上传文件的话，直接可以上传到该项目即可。。。\n\n整体效果，如下：\n#### 项目结构\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190313233907508.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n#### 首页效果\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190313222119329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n#### 日志查看![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190313222544156.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n#### (1)解决了什么问题？\n\n - 简化其他项目的文件处理（上传 | 下载）问题，统一处理\n - 个人的小云盘，并且可以提供外链访问下载等\n\n> 这个文件系统主要功能其中包括`上传文件`、`下载文件`、`在线观看`、`删除文件`、`文件检索`、`访问监控`、`防盗链`等\n> 其中文件是存储在七牛云服务器上的，简要介绍一下，七牛云有10G的对象存储空间可以使用,永久的,支持http,不提供https流量,所以这也是我撘文件系统的原因之一，就是为了小程序的https....否则小程序无法访问图片\n\n#### 防盗链效果\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190313225348446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\nbut 对于爬虫来说无任何阻碍【捂脸】\n\n#### (2)用到的技术栈\n - ##### 前端\n   - freemarker\n   - bootstrap\n   - bootstrap-table\n   - jquery\n - ##### 后台\n   - springboot 2.1.3.RELEASE\n   - spring-data-jpa 2.1.3.RELEASE\n   - mysql 5.7\n\n - ##### 搭建\n    - tomcat 9.0.1 (or 7.0)\n    - maven 3.5.4\n\n - ##### 其他依赖\n    - qiniu[7.2.0, 7.2.99]\n    - fastjson 1.2.54\n\n\n#### (3)未来的期望\n暂时的话不想继续完善了，先实习然后学习一段时间先，基本功能差不多，继续添加的功能的话，就是为了用技术而作了，等有时间了会考虑继续迭代吧\n\n- 多用户(用户管理)\n- 文件管理(文件签名)\n- 权限控制（spring security）\n- 分布式文件存储（hadoop HDFS）：正在学习中...\n\n#### (4)哪里下载\n\n* [github](https://github.com/HouYuSource/filesystem.git)\n\n导入注意事项:\n\n 1. sql文件 \n\n    修改 application.properties\n    ```properties\n    spring.jpa.hibernate.ddl-auto=create-drop # 自动创建表\n    ```\n 2. 修改数据库\n    ```properties\n    spring.datasource.url=jdbc:mysql://localhost/{database}?characterEncoding=utf-8&useSSL=false&serverTimezone=UTC\n    ```\n \n 4. 七牛云配置\n    前往[七牛云官网](https://portal.qiniu.com)注册账号,并且获取绑定好域名,如果不绑定,七牛云提供一个月的免费域名,一个月后失效,建议绑定自己的,前往[对象存储](https://portal.qiniu.com/bucket)创建`Bucket`,并且获取`accessKey` `secretKey` `domainOfBucket`在util.QiniuUtil.java文件中修改对应的配置即可。\n    ```java\n	private static final String accessKey = \"your accessKey\";\n    private static final String secretKey = \"your secretKey\";\n    private static final String bucket = \"your bucket\";\n    private static final Configuration cfg = new Configuration(Zone.zone0());\n    private static final String domainOfBucket = \"your domainOfBucket\";\n    ```\n\n\n##### 交流\n博客同步到[SHY BLOG](https://www.shaines.cn)\nmail ：for.houyu@qq.com', '2019-03-13 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190720191524415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70', NULL, 1, 532, 1, '前几天搞了一个文件管理系统，因为几乎做每一个项目都涉及到上传文件这一步骤，不可能每一个项目都做一个模块处理文件，所以我最近整了一个小文件系统来用，这样子别的项目上传文件的话，直接可以上传到该项目即可。。。', '开源,java', 'springboot快速搭建文件管理系统', '20190713', 'houyu', 12);
INSERT INTO `blog` VALUES ('1150333189655404544', '1154239115950747648', 'A02_JAVA', 1, '> 最近公司有一个需求是接入第三方支付(微信&支付宝),我接到了支付宝支付,所以本博客主要就简述我如何面像文档编程的经过，和中间遇到的小坑小洼，只要一步一步来操作，轻松接入alipay\n> 微信支付的话,等有时间了,我向部门伙伴请教,看看套路是否差不多,到时候再写一篇关于接入微信支付的.\n> 其实个人觉得,了解了一篇的话也一通百通了,毕竟还能差多少呢?\n\n## 接入明确几点\n - 是否满足申请条件(非常最要,貌似个人的话搞不了的,不过可以玩一下沙箱测试) \n - 业务场景(非常重要)\n - 接入流程(最重要)\n - 文档开发(重要)\n\n#### 业务场景\n首先[蚂蚁金服开放平台](https://openhome.alipay.com/developmentDocument.htm)先去看看你需要开发的场景是哪一类,然后确认无误之后,进行申请等.\n\n#### 接入流程\n很爽的就是,我接手的时候是公司申请好了企业号,然后我根据具体业务需求\n1. 创建应用 : (我的业务是:手机网站支付),然后创建应用之后需要审核一个工作日,其实大概5-6小时的话就审核下来了,注意的是\n2. 添加功能 : `创建了应用还不具备开发的条件`你还需要添加应用的功能,这一步必须要注意呀,我一开始以为可以了,结果测试的时候会报一个错`(错误代码 insufficient-isv-permissions 错误原因: ISV权限不足)`,就是没有添加应用的功能的错误。需要审核2 - 3小时(审核速度还是比较快的~~~)\n3. 这个时候就可以看一下官方的DEMO or 相关文档了\n\n#### 文档开发\n个人的建议,你这个时候可以先看一下相关的官方文档,以下推荐几个网址可以详细阅读\n* [手机网站支付文档](https://docs.open.alipay.com/203/105285/)\n* [手机网站支付请求参数说明](https://docs.open.alipay.com/203/107090)\n* [网站调用支付宝进行支付](https://www.jianshu.com/p/09a1d7494c10)\n* [如何生成RSA，RSA2密钥](https://openclub.alipay.com/read.php?tid=1833&fid=46)\n\n好了,如果你开发中遇到问题,可以优先查这几个文档先,你会有意想不到的收获.\n\n##### 步骤01:下载官方的DEMO\nhttps://docs.open.alipay.com/203/105910/\n这里有JAVA PHP.NET等\n\n如何查看?这是一个eclpise的工程,自行想办法[奸笑]\n先查看 WebContent > index.html\n然后根据button的点击事件查看对应的模块,如:支付、订单查询、订单退款、订单退款查询、账单下载\n\n\n##### 步骤02:生成RSA2密钥\nhttps://openclub.alipay.com/read.php?tid=1833&fid=46\n查看这篇文章,了解一下什么是密钥什么是公钥等,然后按照步骤生成应用的RSA2密钥,`私钥将放入代码中，公钥传入应用中`\n\n注: `这里有一个坑,密钥长度2048指的是RSA2,我当初不知道,然后找资料,就在这里了解到`\n\n\n##### 步骤03:编写代码\n\n* ### 添加依赖\n\n```java\n<!--导入阿里支付相关依赖-->\n<dependency>\n	<groupId>com.alipay.sdk</groupId>\n	<artifactId>alipay-sdk-java</artifactId>\n	<version>3.7.4.ALL</version>\n</dependency>\n\n<!--alibaba fastjson-->\n<dependency>\n	<groupId>com.alibaba</groupId>\n	<artifactId>fastjson</artifactId>\n	<version>1.2.54</version>\n</dependency>\n```\n\n* ### AlipayConfig\n \n```java\n/**\n * @author houyu\n * @createTime 2019/3/19 23:39\n */\npublic class AlipayConfig {\n\n    // 商户appid\n    public static String APPID = \"20190319635xxxxx\";\n    // 私钥 pkcs8格式的\n    public static String RSA_PRIVATE_KEY = \"MIIEvgIBADANBxxxxx ....  xxxxxxxxx+I\";\n    // 服务器异步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问\n    public static String notify_url = \"http://your hostname/alipay/notify\";\n    // 页面跳转同步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 商户可以自定义同步跳转地址\n    public static String return_url = \"http://your hostname/alipay/return\";\n    // 请求网关地址,沙箱是:https://openapi.alipaydev.com/gateway.do\n    public static String URL = \"https://openapi.alipay.com/gateway.do\";\n    // 编码\n    public static String CHARSET = \"UTF-8\";\n    // 返回格式\n    public static String FORMAT = \"json\";\n    // 支付宝公钥(在应用中可以获取)\n    public static String ALIPAY_PUBLIC_KEY = \"MIIBIxxxxxxxx ....  xxxxxxxxx\";\n    // RSA2\n    public static String SIGNTYPE = \"RSA2\";\n\n}\n\n```\n\n* ### AlipayVo\n\n```java\nimport java.io.Serializable;\n\n/**\n * @author houyu\n * @createTime 2019/3/19 23:31\n */\npublic class AlipayVo implements Serializable {\n\n    /**\n     * 订单名称\n     */\n    private String subject;\n    /**\n     * 商户网站唯一订单号\n     */\n    private String out_trade_no;\n    /**\n     * 该笔订单允许的最晚付款时间\n     */\n    private String timeout_express;\n    /**\n     * 付款金额\n     */\n    private String total_amount;\n    /**\n     * 销售产品码，与支付宝签约的产品码名称\n     */\n    private String product_code;\n\n	// getter and setter ....\n}\n\n```\n\n* ### AlipayUtil\n\n```java\nimport com.alipay.api.AlipayApiException;\nimport com.alipay.api.internal.util.AlipaySignature;\nimport com.juiniot.alipaydemo.config.AlipayConfig;\n\nimport java.lang.management.ManagementFactory;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author houyu\n * @createTime 2019/3/20 8:38\n */\npublic class AlipayUtil {\n\n    /**\n     * 处理请求参数\n     * @param requestParams\n     * @return\n     */\n    public static Map<String, String> handleParams(Map<String, String[]> requestParams){\n        Map<String, String> handleMap = new HashMap<>(requestParams.size());\n        for (Map.Entry<String, String[]> entry : requestParams.entrySet()) {\n            String key = entry.getKey();\n            String[] value = entry.getValue();\n            handleMap.put(key, join(value, \",\"));\n        }\n        return handleMap;\n    }\n\n    /**\n     * 数组转字符串  [\"1\", \"2\"]  ==> \"1,2\"\n     * @param os\n     * @param splitString\n     * @return\n     */\n    public static String join(Object[] os, String splitString){\n        String s = \"\";\n        if (os != null) {\n            StringBuilder sBuffer = new StringBuilder();\n            for (int i = 0; i < os.length; i++) {\n                sBuffer.append(os[i]).append(splitString);\n            }\n            s = sBuffer.deleteCharAt(sBuffer.length() - 1).toString();\n        }\n        return s;\n    }\n\n    /**\n     * 校验是否支付成功\n     * @param handleParams\n     * @return\n     */\n    public static boolean rsaCheck(Map<String, String> handleParams) {\n        boolean checkV1 = false;\n        try {\n            checkV1 = AlipaySignature.rsaCheckV1(handleParams, AlipayConfig.ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, AlipayConfig.SIGNTYPE);\n        } catch (AlipayApiException e) {\n            e.printStackTrace();\n        }\n        return checkV1;\n    }\n\n    /** ---------------------------------------单例模式---------------------------------------*/\n    private static class SingletonHolder {\n        private static final AlipayUtil INSTANCE = new AlipayUtil();\n    }\n    public static AlipayUtil get() {\n        return SingletonHolder.INSTANCE;\n    }\n    /** ---------------------------------------单例模式---------------------------------------*/\n\n    /**  雪花算法生成ID,自带时间排序,一秒可以生成25万个ID左右 */\n\n    // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动）\n    private final static long twepoch = 1288834974657L;\n    // 机器标识位数\n    private final static long workerIdBits = 5L;\n    // 数据中心标识位数\n    private final static long datacenterIdBits = 5L;\n    // 机器ID最大值\n    private final static long maxWorkerId = -1L ^ (-1L << workerIdBits);\n    // 数据中心ID最大值\n    private final static long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);\n    // 毫秒内自增位\n    private final static long sequenceBits = 12L;\n    // 机器ID偏左移12位\n    private final static long workerIdShift = sequenceBits;\n    // 数据中心ID左移17位\n    private final static long datacenterIdShift = sequenceBits + workerIdBits;\n    // 时间毫秒左移22位\n    private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;\n\n    private final static long sequenceMask = -1L ^ (-1L << sequenceBits);\n    /* 上次生产id时间戳 */\n    private static long lastTimestamp = -1L;\n    // 0，并发控制\n    private long sequence = 0L;\n\n    private final long workerId;\n    // 数据标识id部分\n    private final long datacenterId;\n\n    public AlipayUtil() {\n        this.datacenterId = getDatacenterId(maxDatacenterId);\n        this.workerId = getMaxWorkerId(datacenterId, maxWorkerId);\n    }\n\n    /**\n     * @param workerId     工作机器ID\n     * @param datacenterId 序列号\n     */\n    public AlipayUtil(long workerId, long datacenterId) {\n        if (workerId > maxWorkerId || workerId < 0) {\n            throw new IllegalArgumentException(String.format(\"worker Id can\'t be greater than %d or less than 0\", maxWorkerId));\n        }\n        if (datacenterId > maxDatacenterId || datacenterId < 0) {\n            throw new IllegalArgumentException(String.format(\"datacenter Id can\'t be greater than %d or less than 0\", maxDatacenterId));\n        }\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n    }\n\n    /**\n     * 获取下一个ID\n     *\n     * @return\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n        if (timestamp < lastTimestamp) {\n            throw new RuntimeException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n        }\n\n        if (lastTimestamp == timestamp) {\n            // 当前毫秒内，则+1\n            sequence = (sequence + 1) & sequenceMask;\n            if (sequence == 0) {\n                // 当前毫秒内计数满了，则等待下一秒\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {\n            sequence = 0L;\n        }\n        lastTimestamp = timestamp;\n        // ID偏移组合生成最终的ID，并返回ID\n        long nextId = ((timestamp - twepoch) << timestampLeftShift)\n                | (datacenterId << datacenterIdShift)\n                | (workerId << workerIdShift) | sequence;\n\n        return nextId;\n    }\n\n    private long tilNextMillis(final long lastTimestamp) {\n        long timestamp = this.timeGen();\n        while (timestamp <= lastTimestamp) {\n            timestamp = this.timeGen();\n        }\n        return timestamp;\n    }\n\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    /**\n     * <p>\n     * 获取 maxWorkerId\n     * </p>\n     */\n    protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) {\n        StringBuffer mpid = new StringBuffer();\n        mpid.append(datacenterId);\n        String name = ManagementFactory.getRuntimeMXBean().getName();\n        if (!name.isEmpty()) {\n            /*\n             * GET jvmPid\n             */\n            mpid.append(name.split(\"@\")[0]);\n        }\n        /*\n         * MAC + PID 的 hashcode 获取16个低位\n         */\n        return (mpid.toString().hashCode() & 0xffff) % (maxWorkerId + 1);\n    }\n\n    /**\n     * <p>\n     * 数据标识id部分\n     * </p>\n     */\n    protected static long getDatacenterId(long maxDatacenterId) {\n        long id = 0L;\n        try {\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n            if (network == null) {\n                id = 1L;\n            } else {\n                byte[] mac = network.getHardwareAddress();\n                id = ((0x000000FF & (long) mac[mac.length - 1])\n                        | (0x0000FF00 & (((long) mac[mac.length - 2]) << 8))) >> 6;\n                id = id % (maxDatacenterId + 1);\n            }\n        } catch (Exception e) {\n            System.out.println(\" getDatacenterId: \" + e.getMessage());\n        }\n        return id;\n    }\n\n    /**  雪花算法生成ID,自带时间排序,一秒可以生成25万个ID左右 */\n\n}\n\n```\n\n* ### AlipayController\n\n```java\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.alipay.api.AlipayApiException;\nimport com.alipay.api.AlipayClient;\nimport com.alipay.api.DefaultAlipayClient;\nimport com.alipay.api.request.AlipayTradeWapPayRequest;\nimport com.juiniot.alipaydemo.config.AlipayConfig;\nimport com.juiniot.alipaydemo.util.AlipayUtil;\nimport com.juiniot.alipaydemo.vo.AlipayVo;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.Map;\n\n/**\n * @author houyu\n * @createTime 2019/3/19 23:29\n */\n@SuppressWarnings(\"Duplicates\")\n@Controller\n@RequestMapping(\"/alipay\")\npublic class AlipayController {\n\n    /**\n     * 测试代码是否跑通\n     * @return\n     */\n    @RequestMapping(\"/hello\")\n    @ResponseBody\n    public String hello() {\n        return \"hello\";\n    }\n\n    /**\n     * 支付宝完成回调页面(不可信回调)\n     */\n    @GetMapping(\"/return\")\n    @ResponseBody\n    private String alipayReturn(HttpServletRequest request) {\n\n        Map<String, String[]> parameterMap = request.getParameterMap();\n        Map<String, String> handleParams = AlipayUtil.handleParams(parameterMap);\n\n        // 这里的校验没有多大的意思,不可信,直接获取out_trade_no跳转到对应的payed controller也可\n        boolean rsaCheck = AlipayUtil.rsaCheck(handleParams);\n        if (rsaCheck){\n            System.out.println(\"验证通过\");\n        }else {\n            System.out.println(\"验证失败\");\n        }\n\n        // 获取订单号\n        String out_trade_no = handleParams.get(\"out_trade_no\");\n        System.out.println(\"out_trade_no:\" + out_trade_no);\n        // 这里一般都是 重定向 payed的controller, 然后携带对应的信息如:return \"redirect:/alipay/success?out_trade_no=\" + out_trade_no;\n        // payed的controller根据out_trade_no获取支付结果,并且给出页面提示\n\n        return \"支付完成\";\n    }\n\n\n    /**\n     * 支付宝完成结果异步的回调(可信回调)\n     * @param request\n     */\n    @PostMapping(\"/notify\")\n    @ResponseBody\n    private String alipayNotify(HttpServletRequest request) {\n\n        Map<String, String[]> parameterMap = request.getParameterMap();\n        Map<String, String> handleParams = AlipayUtil.handleParams(parameterMap);\n\n        boolean rsaCheck = AlipayUtil.rsaCheck(handleParams);\n        if (rsaCheck){\n            System.out.println(\"验证通过\");\n\n            // 处理业务逻辑,更改支付状态等骚操作\n            // ...\n        }else {\n            System.out.println(\"验证失败\");\n        }\n        return rsaCheck ? \"success\" : \"failure\";\n    }\n\n    @RequestMapping(\"/pay\")\n    @ResponseBody\n    public String pay() {\n\n        AlipayVo alipayVo = new AlipayVo();\n        // String out_trade_no = UUID.randomUUID().toString().replace(\"-\", \"\");\n         String out_trade_no = AlipayUtil.get().nextId() + \"\";\n        System.out.println(\"out_trade_no:\" + out_trade_no);\n        // 设置订单单号,需要保证唯一性\n        alipayVo.setOut_trade_no(out_trade_no);\n        // 设置支付金额\n        alipayVo.setTotal_amount(\"0.01\");\n        // 设置支付标题\n        alipayVo.setSubject(\"houyu-test-title\");\n        // 设置订单有效时长(30分钟)\n        alipayVo.setTimeout_express(\"30m\");\n        // 商品码(必须是QUICK_WAP_WAY),可以看文档 see: https://docs.open.alipay.com/203/107090/\n        alipayVo.setProduct_code(\"QUICK_WAP_WAY\");\n\n        // 对象转为json字符串\n        String json = JSONObject.toJSONString(alipayVo);\n\n        // 建立连接\n        AlipayClient client = new DefaultAlipayClient(AlipayConfig.URL, AlipayConfig.APPID, AlipayConfig.RSA_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, AlipayConfig.ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE);\n\n        // 创建请求\n        AlipayTradeWapPayRequest alipayTradeWapPayRequest = new AlipayTradeWapPayRequest();\n\n        // 设置异步通知地址\n        alipayTradeWapPayRequest.setNotifyUrl(AlipayConfig.notify_url);\n        // 设置对调地址,就是说支付成功之后回调你的页面,你可以继续进行你的业务操作,但是这个是不可信任的,需要根据notify_url这边的回调确定支付是否成功\n        alipayTradeWapPayRequest.setReturnUrl(AlipayConfig.return_url);\n\n        // 封装请求支付信息\n        alipayTradeWapPayRequest.setBizContent(json);\n\n        String pageString;\n        try {\n            pageString = client.pageExecute(alipayTradeWapPayRequest).getBody();\n        } catch (AlipayApiException e) {\n            pageString = \"request aliapy has error\";\n            e.printStackTrace();\n        }\n        return pageString;\n    }\n\n\n}\n\n\n```\n\n#### 以上代码应该算是清晰明了的了,希望对你有帮助....\n\n#### 建议:\n对于这种开发形文档,随时可能更新,如果接入失败了,优先查看官网的文档解决,有可能接口更新了\n\n#### 交流:\n如果接入过程有问题,可以一起交流!!!\nfor.houyu@qq.com\n272694308@qq.com', '2019-03-21 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727143836547.png', NULL, 1, 494, 1, '最近公司有一个需求是接入第三方支付(微信&支付宝),我接到了支付宝支付,所以本博客主要就简述我如何面像文档编程的经过，和中间遇到的小坑小洼，只要一步一步来操作，轻松接入alipay\n微信支付的话,等有时间了,我向部门伙伴请教,看看套路是否差不多,到时候再写一篇关于接入微信支付的.\n其实个人觉得,了解了一篇的话也一通百通了,毕竟还能差多少呢?', 'java,支付', 'Java接入支付宝支付(alipay)', '20190713', 'houyu', 2);
INSERT INTO `blog` VALUES ('1150333434749558784', '1154241060761432064', 'A02_JAVA_框架', 0, '> spring cloud 越来越流行了,当初学习的时候都是使用maven构建的cloud(网上很多的springcloud案例也是通过maven构建的,gradle构建的cloud资料很少,或者说不全面),所以我一直想使用gradle构建一个cloud的demo.上周花了一个晚上整了一个demo,今天找个时间写一篇博客记录下....\n直入主题>>>>>>\n\n使用的版本如下:\n`springBootVersion = \'2.0.1.RELEASE\'`\n`springCloudVersion = \'Finchley.RELEASE\'`\n需要对应:\n可以去springcloud官网查看springboot对应的springcloud版本\nhttps://spring.io/projects/spring-cloud\n这里贴出来....\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190414194351535.png)\n整的时候遇到了一个小坑就是`dependencyManagement`插件问题,这个插件主要是解决cloud零散jar的版本问题,我之前使用maven构建的使用就是因为这个插件安装失败,所以很难受,一个jar的版本都需要自己控制,这次使用gradle构建的使用使用了dependencyManagement插件后很舒服,直接引用对应的jar即可,版本不需要自己管理了...\n\n这里使用一个demo案例主要实现\n1. eureka的服务注册与发现\n2. 微服务基于Feign的调用\n3. 服务的熔断器hystrix\n\n这里使用的比较简单,主要是作为一个spring cloud 的一个 hello world \n\n其他组件在上面进行扩展即可,比如说一些常用的组件\n* spring-cloud-config 配置\n* spring-cloud-gateway 网关\n* spring-cloud-bus 消息总线\n* spring-cloud-security 安全认证\n* Spring Cloud Zookeeper 服务注册与管理\n\n----\n现在先来看看整体效果吧\n启动顺序\n1. eureka\n2. user\n3. test\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/2019041420475092.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n贴出一个关键的配置\n1. cloud_demo.build.gradle\n\n```java\ngroup \'cn.shaines\'\nversion \'0.1.1\'\n\nbuildscript {\n    ext {\n        // 定义变量\n        springBootVersion = \'2.0.1.RELEASE\'\n        springCloudVersion = \'Finchley.RELEASE\'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n\nallprojects {\n    apply plugin: \'java\'\n    apply plugin: \'org.springframework.boot\'\n    apply plugin: \'io.spring.dependency-management\'\n\n    sourceCompatibility = 1.8\n    targetCompatibility = 1.8\n\n    dependencyManagement {\n        imports {\n            // 解决cloud零散jar的版本问题\n            mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n        }\n    }\n\n    // 统一移除jar\n    /*configurations {\n        all*.exclude module: \'spring-boot-starter-logging\'\n        all*.exclude module: \'logback-classic\'\n    }*/\n\n    repositories {\n        mavenCentral()\n    }\n\n    dependencies {\n        compile(\'org.springframework.boot:spring-boot-starter\')\n        compile(\'org.springframework.boot:spring-boot-starter-web\')\n        compile(\'org.springframework.boot:spring-boot-starter-test\')\n        // compile \':spring-cloud-starter-config\'\n        // compile \':spring-cloud-starter-eureka\'\n\n        // compile(group: \'com.qcloud\', name: \'cos_api\', version:\'4.4\') {\n        //     exclude(module: \'slf4j-log4j12\')\n        // }\n    }\n}\n\n\n```\n\n2. eureka.build.gradle\n\n```java\ndependencies {\n    compile(\'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server\')\n}\n\n```\n\n3. eureka.application.yml\n\n```java\nserver:\n  port: 6868\nspring:\n  application:\n    name: eureka\neureka:\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n      # 浏览器打开: http://localhost:6868/\n      defaultZone: http://127.0.0.1:${server.port}/eureka/\n```\n\n项目坐标\nhttps://github.com/HouYuSource/cloud_demo\n\n最后唠叨一下\n学习cloud的对电脑的内存有一定要求,\n8G最基本,\n16G勉勉强强\n32G最理想\n我之前学习的时候8G(4+4), 昨天闲鱼160入手一个二手三星8G现在的话(4+8),不知道能活多久,哈哈哈...(准备闲鱼出4G内存条,有需要的话可以联系我呀[奸笑]:272694308@qq.com)\n* 现在是12G开了3个微服务58%)  >>>> 当初学习8G开4个服务就93%\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190414210222331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc)\n\n学习与交流\nfor.houyu@qq.com\n272694308@qq.com\n\n我的博客\nhttps://shaines.cn\n\n\n\n\n', '2019-04-14 00:00:00', ' https://shaines.cn/view/image?src=http://www.springcloud.com/sites/default/files/logo_uploads/43741/large_springcloud1.png', NULL, 1, 640, 1, 'spring cloud 越来越流行了,当初学习的时候都是使用maven构建的cloud(网上很多的springcloud案例也是通过maven构建的,gradle构建的cloud资料很少,或者说不全面),所以我一直想使用gradle构建一个cloud的demo.上周花了一个晚上整了一个demo,今天找个时间写一篇博客记录下…\n直入主题>>>>>>', 'springcloud,java', '使用gradle构建spring cloud,搭建一个cloud的helloworld', '20190713', 'houyu', 8);
INSERT INTO `blog` VALUES ('1150333723179261952', '1154240574968754176', 'A02_JAVA_爬虫', 0, '> 很久没写过爬虫了，其实我挺喜欢写爬虫的，所以今天找了个时间写一个爬虫吧\n> 先说为什么要写这个爬虫，因为我公司的电梯有一个广告牌子，每天上下班，吃饭的时候都被洗脑，`“上智联你更值”`,一个智联的招聘广告,高晓松每天都叫我上智联.....\n> 广告这东西对吧,没用呀,得看数据呀,所以故事就这样子开始了......\n\n没错啦!!!就是下边这个啦\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmRzdGF0aWMuY29tLy0wVTBiblNtMUE1QnBoR2xuWUcvdGFtLW9nZWwvMmIwMWNhMjM5MTVlNzk2YzBhZTEyZDU3NGYwYWFhNDZfMjU5XzE5NC5qcGc)\n\n##### 实现步骤:\n##### 01: 先打开熟悉的百度搜索 \"智联\", 然后选择 \"中山\", 搜索 \"java\"\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190421214252985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n##### 02: 浏览器抓包(具体流程阅图)\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190421214942825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n##### 03: 到了这里我们就知道了浏览器的数据是怎么来的了,然后下一步我们就是模拟浏览器发送网络请求拿到数据啦~~\n>其实现在很多数据的加载都是异步的加载上来了,很少写死在html中了,有机会的话可以分析一下抓取html中的数据\n\n这里使用的java,其实什么语言都无所谓,但是爬虫的话,python相对来说友好一点, 方便很多\n\n```java\npackage cn.shaines.spider.module.job;\n\nimport cn.shaines.spider.module.SpiderInterface;\nimport cn.shaines.spider.util.HappyUtil;\nimport cn.shaines.spider.util.HttpUtil;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONArray;\nimport com.alibaba.fastjson.JSONObject;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author houyu\n * @createTime 2019/4/21 20:59\n */\npublic class ZhiLianZSSpider implements SpiderInterface {\n\n    HttpUtil httpUtil = HttpUtil.get();       // 自己封装的一个网络请求工具类,\n    HappyUtil happyUtil = HappyUtil.get();    // 自己封装的一个公用工具类\n\n    /**\n     * 处理薪资词云图\n     * @return\n     */\n    private Object handlerSalary(){\n        List<Map<String, Object>> dataList = (List<Map<String, Object>>)process(null);\n\n        System.out.println(\"智联中山java招聘信息共: \" + dataList.size() + \" 条\");\n\n        List<String> list = new ArrayList<>(dataList.size());\n        dataList.forEach((v) -> list.add((String)v.get(\"薪资待遇\")));\n        Map<String, Integer> salaryMap = happyUtil.getAloneCountInList(list);\n\n        System.out.println(\"salaryMap = \" + salaryMap);\n\n        return null;\n    }\n\n    /**\n     * 解析网页数据\n     * @param param\n     * @return\n     */\n    @Override\n    public Object process(Map<String, Object> param) {\n        String html = getHtml(1);\n        JSONObject jsonObject = JSON.parseObject(html);\n        JSONArray jsonArray = jsonObject.getJSONObject(\"data\").getJSONArray(\"results\");\n\n        Map<String, Object> dataMap = null;\n        List<Map<String, Object>> dataList = new ArrayList<>(1024);\n\n        for (int i = 0; i < jsonArray.size(); i++) {\n            JSONObject data = jsonArray.getJSONObject(i);\n            dataMap = new HashMap<>(16);\n\n            String 更新时间 = data.getString(\"updateDate\");\n            String 结束时间 = data.getString(\"endDate\");\n            String 所属城市 = data.getJSONObject(\"city\").getString(\"display\");\n            String 详情网址 = data.getString(\"positionURL\");\n            String 福利多多 = happyUtil.join(data.getJSONArray(\"welfare\").toArray(), \",\");\n            String 薪资待遇 = data.getString(\"salary\");\n            String 工作年限 = data.getJSONObject(\"workingExp\").getString(\"name\");\n            dataMap.put(\"更新时间\", 更新时间);\n            dataMap.put(\"结束时间\", 结束时间);\n            dataMap.put(\"所属城市\", 所属城市);\n            dataMap.put(\"详情网址\", 详情网址);\n            dataMap.put(\"福利多多\", 福利多多);\n            dataMap.put(\"薪资待遇\", 薪资待遇);\n            dataMap.put(\"工作年限\", 工作年限);\n\n            String 公司代码 = data.getJSONObject(\"company\").getString(\"number\");\n            String 公司规模 = data.getJSONObject(\"company\").getJSONObject(\"size\").getString(\"name\");\n            String 公司名称 = data.getJSONObject(\"company\").getString(\"name\");\n            String 公司类型 = data.getJSONObject(\"company\").getJSONObject(\"type\").getString(\"name\");\n            String 招聘网址 = data.getJSONObject(\"company\").getString(\"url\");\n            dataMap.put(\"公司代码\", 公司代码);\n            dataMap.put(\"公司规模\", 公司规模);\n            dataMap.put(\"公司名称\", 公司名称);\n            dataMap.put(\"公司类型\", 公司类型);\n            dataMap.put(\"招聘网址\", 招聘网址);\n\n            String 岗位简介 = data.getJSONObject(\"jobType\").getString(\"display\");\n            String 招聘人数 = data.getString(\"recruitCount\");\n            String 创建时间 = data.getString(\"createDate\");\n            String 岗位名称 = data.getString(\"jobName\");\n            String 学历底线 = data.getJSONObject(\"eduLevel\").getString(\"name\");\n            String 工作制度 = data.getString(\"emplType\");\n            String 区域名称 = data.getString(\"businessArea\");\n            dataMap.put(\"岗位简介\", 岗位简介);\n            dataMap.put(\"招聘人数\", 招聘人数);\n            dataMap.put(\"创建时间\", 创建时间);\n            dataMap.put(\"岗位名称\", 岗位名称);\n            dataMap.put(\"学历底线\", 学历底线);\n            dataMap.put(\"工作制度\", 工作制度);\n            dataMap.put(\"区域名称\", 区域名称);\n\n            JSONObject positionLabel = JSON.parseObject(data.getString(\"positionLabel\"));\n            JSONArray jobLight = positionLabel.getJSONArray(\"jobLight\");\n            String 工作福利 = happyUtil.join(jobLight == null ? new String[]{} : jobLight.toArray(), \",\");\n            dataMap.put(\"工作福利\", 工作福利);\n\n            JSONArray skill = positionLabel.getJSONArray(\"skill\");\n            String 掌握技能 = happyUtil.join(skill == null ? new String[]{} : skill.toArray(), \",\");\n            dataMap.put(\"掌握技能\", 掌握技能);\n\n            System.out.println(\"dataMap = \" + dataMap);\n            dataList.add(dataMap);\n        }\n        return dataList;\n    }\n\n    /**\n     * 网络请求数据\n     * @param page\n     * @return\n     */\n    private String getHtml(int page){\n        String url = \"https://fe-api.zhaopin.com/c/i/sou?pageSize=1000&cityId=780&workExperience=-1&education=-1&companyType=-1&employmentType=-1&jobWelfareTag=-1&kw=java&kt=3\";\n        String html = httpUtil.getHtml(url);\n        // System.out.println(html);\n        return html;\n    }\n\n    /**\n     * main\n     */\n    public static void main(String[] args) {\n        ZhiLianZSSpider zhiLianZSSpider = new ZhiLianZSSpider();\n        //zhiLianZSSpider.process(null);\n        zhiLianZSSpider.handlerSalary();\n    }\n\n}\n\n```\n\n##### 04: 控制台输出\n\n```java\ndataMap = {区域名称=竹苑, 公司代码=CZ372359780, 工作制度=全职, 公司规模=20-99人, 公司名称=中山市日淘乐网络信息有限公司, 招聘人数=3, 更新时间=2019-04-21 19:22:21, 招聘网址=https://company.zhaopin.com/CZ372359780.htm, 岗位简介=软件/互联网开发/系统集成,互联网软件工程师, 公司类型=民营, 掌握技能=JS,Java,MySQL,HTML,CSS, 岗位名称=中高级JAVA开发工程师, 工作福利=带薪年假,交通补助,加班补助,绩效奖金,年底双薪,弹性工作,14薪,住房补贴, 工作年限=3-5年, 创建时间=2019-04-06 13:06:15, 福利多多=带薪年假,交通补助,加班补助,绩效奖金,年底双薪, 学历底线=大专, 结束时间=2019-05-16 13:06:15, 所属城市=中山, 详情网址=https://jobs.zhaopin.com/372359783250004.htm, 薪资待遇=6K-10K}\ndataMap = {区域名称=竹苑, 公司代码=CZ633142420, 工作制度=全职, 公司规模=1000-9999人, 公司名称=朗新科技股份有限公司, 招聘人数=4, 更新时间=2019-04-03 19:27:05, 招聘网址=https://company.zhaopin.com/CZ633142420.htm, 岗位简介=软件/互联网开发/系统集成,Java开发工程师, 公司类型=合资, 掌握技能=, 岗位名称=高级应用开发工程师（java）(J10469), 工作福利=五险一金,交通补助,带薪年假,弹性工作,补充医疗保险,定期体检,员工旅游,节日福利, 工作年限=3-5年, 创建时间=2019-03-28 14:50:23, 福利多多=五险一金,交通补助,带薪年假,弹性工作,补充医疗保险, 学历底线=本科, 结束时间=2020-01-22 14:50:23, 所属城市=中山, 详情网址=https://jobs.zhaopin.com/CC633142422J00291422403.htm, 薪资待遇=10K-15K}\ndataMap = {区域名称=湖滨北路, 公司代码=CZ318025530D00300163186, 工作制度=全职, 公司规模=10000人以上, 公司名称=中山达内科技有限公司, 招聘人数=3, 更新时间=2019-04-07 17:44:46, 招聘网址=https://company.zhaopin.com/CZ318025530D00300163186.htm, 岗位简介=软件/互联网开发/系统集成,PHP开发工程师, 公司类型=上市公司, 掌握技能=, 岗位名称=初级Java软件工程师, 工作福利=五险一金,年底双薪,绩效奖金,加班补助,餐补,股票期权,带薪年假,周末双休, 工作年限=不限, 创建时间=2019-03-29 17:15:03, 福利多多=五险一金,年底双薪,绩效奖金,加班补助,餐补, 学历底线=不限, 结束时间=2019-04-28 17:15:03, 所属城市=中山-西区, 详情网址=https://jobs.zhaopin.com/CC318025533J00146991002.htm, 薪资待遇=6K-8K}\ndataMap = {区域名称=张家边, 公司代码=CZ369469780, 工作制度=全职, 公司规模=100-499人, 公司名称=QST青软实训, 招聘人数=2, 更新时间=2019-04-19 09:48:27, 招聘网址=https://company.zhaopin.com/CZ369469780.htm, 岗位简介=软件/互联网开发/系统集成,Java开发工程师, 公司类型=股份制企业, 掌握技能=C++,Java, 岗位名称=java讲师【中山】, 工作福利=周末双休,五险一金,年底双薪,餐补,节日福利,不加班,免费班车,定期体检, 工作年限=3-5年, 创建时间=2019-04-19 09:48:26, 福利多多=周末双休,五险一金,年底双薪,餐补,节日福利, 学历底线=本科, 结束时间=2019-05-19 09:48:26, 所属城市=中山-火炬开发区, 详情网址=https://jobs.zhaopin.com/CC369469780J00255567603.htm, 薪资待遇=8K-12K}\ndataMap = {区域名称=上步, 公司代码=CZ120564550, 工作制度=全职, 公司规模=1000-9999人, 公司名称=深圳市长亮科技股份有限公司, 招聘人数=5, 更新时间=2019-04-08 11:23:43, 招聘网址=https://company.zhaopin.com/CZ120564550.htm, 岗位简介=软件/互联网开发/系统集成,软件工程师, 公司类型=上市公司, 掌握技能=, 岗位名称=Java开发工程师（互联网金融）, 工作福利=五险一金,绩效奖金,包住,通讯补助,带薪年假,定期体检,员工旅游,节日福利, 工作年限=3-5年, 创建时间=2019-04-08 11:23:43, 福利多多=五险一金,绩效奖金,包住,通讯补助,带薪年假, 学历底线=本科, 结束时间=2019-05-08 11:23:43, 所属城市=中山, 详情网址=https://jobs.zhaopin.com/120564559253095.htm, 薪资待遇=10K-15K}\ndataMap = {区域名称=, 公司代码=CZ130494460, 工作制度=全职, 公司规模=1000-9999人, 公司名称=深圳天源迪科信息技术股份有限公司, 招聘人数=1, 更新时间=2019-04-04 15:50:58, 招聘网址=https://company.zhaopin.com/CZ130494460.htm, 岗位简介=软件/互联网开发/系统集成,Java开发工程师, 公司类型=民营, 掌握技能=, 岗位名称=java开发工程师, 工作福利=周末双休,五险一金,年底双薪,带薪年假,节日福利,定期体检, 工作年限=3-5年, 创建时间=2019-04-04 15:50:57, 福利多多=周末双休,五险一金,年底双薪,带薪年假,节日福利, 学历底线=大专, 结束时间=2019-05-04 15:50:57, 所属城市=中山, 详情网址=https://jobs.zhaopin.com/CC130494465J00104064207.htm, 薪资待遇=8K-15K}\ndataMap = {区域名称=竹苑, 公司代码=CZ232405810, 工作制度=全职, 公司规模=1000-9999人, 公司名称=北京东方国信科技股份有限公司, 招聘人数=1, 更新时间=2019-04-19 17:17:53, 招聘网址=https://company.zhaopin.com/CZ232405810.htm, 岗位简介=软件/互联网开发/系统集成,Java开发工程师, 公司类型=上市公司, 掌握技能=, 岗位名称=Java开发工程师（GY35clf）, 工作福利=节日福利,五险一金,年底双薪,定期体检,带薪年假, 工作年限=3-5年, 创建时间=2019-04-19 17:17:52, 福利多多=节日福利,五险一金,年底双薪,定期体检,带薪年假, 学历底线=本科, 结束时间=2019-07-18 17:17:52, 所属城市=中山, 详情网址=https://jobs.zhaopin.com/CC232405817J00108223209.htm, 薪资待遇=8K-15K}\n\n......\n\n智联中山java招聘信息共: 94 条\nsalaryMap = {4.5K-8K=1, 薪资面议=2, 5K-8K=6, 6K-12K=3, 6K-8K=9, 15K-30K=1, 5K-10K=6, 8K-12K=5, 4K-7K=2, 10K-15K=6, 4K-6K=8, 10K-20K=4}\n```\n\n##### 05: 数据可视化, 网上很多可视化工具,使用的一个比较简单的展示一下\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190421220224464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190421221456608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n##### 结束语\n* 看到数据的时候,我深呼吸了好几下,连忙安慰了一下自己.不哭,你要坚强...\n* 信息的说明这里就不阐述了,看图说话吧\n* 这里抓到的数据内容比较多,一个url就请求到了所有的信息了,这个是比较理想和比较舒服的\n* 这里抓到的数据只有94条,说明中山的IT行业(java)的企业等需求不高呀\n* 这里只分析了智联的中山java薪资,其实还可以可视化很多数据的,这里就不搞事了,有时间的话可以深入分析\n* 这个故事还没结束,高晓松说了`上智联你更值`,所以下次我再抓58,或者Boss直聘等招聘的信息做一个对比,那就有意思了,是不是更值不是你<高*松>说了算,我看数据说话...\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190421221755746.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)', '2019-04-21 00:00:00', 'https://shaines.cn/view/image?src=http://www.51ebo.com/data/upload/ueditor/20190228/5c776ee65eefa.jpg', NULL, 1, 760, 1, '很久没写过爬虫了，其实我挺喜欢写爬虫的，所以今天找了个时间写一个爬虫吧\n先说为什么要写这个爬虫，因为我公司的电梯有一个广告牌子，每天上下班，吃饭的时候都被洗脑，“上智联你更值”,一个智联的招聘广告,高晓松每天都叫我上智联…\n广告这东西对吧,没用呀,得看数据呀,所以故事就这样子开始了…', '爬虫,数据分析,智联招聘', '爬虫分析智联_中山_java_薪资水平', '20190713', 'houyu', 12);
INSERT INTO `blog` VALUES ('1150334046669152256', '1154240574968754176', 'A02_JAVA_爬虫', 0, '> 找时间再续爬虫啦 智联爬虫未完现续~~~\n> 上一篇博客获取了中山的JAVA薪资水平, 并且数据可视化, 这次主要在于获取深圳的JAVA薪资水平, 顺便和中山对比一下, 你会发现一线城市和二线城市的IT薪资差异了....\n\n上一篇博客 [ 爬虫分析智联_中山_java_薪资水平 ]\nhttp://shaines.cn/u/shy/blogs/25\nhttps://blog.csdn.net/JinglongSource/article/details/89441095\n\n---\n\n### 进入今天主题\n\n#### 01: 智联深圳招聘\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190427180933413.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n了解页面之后,我们看看大概有多少数据, 浏览器滚动条拖到最后, 然后发现没有显示最大页面, 所以我们尝试输入50页, 输入的数字被改写成了12, 也就是说输入框被js监听了, 如果输入大于总页数, 会被动态改写为列表数据的最大页数, 也就是12,至此 就知道了原来智联中深圳JAVA招聘列表一共12页, 综合上一篇博客的数据抓包就可以大概猜测出 一共数据有: 90 * 12 = 1080\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190427181507659.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n抓包在这里就不过多阐述了, 参考上一篇博客 [ 爬虫分析智联_中山_java_薪资水平 ]\nhttp://shaines.cn/u/shy/blogs/25\nhttps://blog.csdn.net/JinglongSource/article/details/89441095\n\n#### 02: JAVA获取数据并且入库\n由于这里数据量有点多, 为了处理方便, 这里选择写入数据库(mysql)\n封装了一个小工具类DbUtil\n上代码如下:\n\n```java\npackage cn.shaines.spider.module.job;\n\nimport cn.shaines.spider.module.SpiderInterface;\nimport cn.shaines.spider.util.DbUtil;\nimport cn.shaines.spider.util.EasyUtil;\nimport cn.shaines.spider.util.HttpUtil;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONArray;\nimport com.alibaba.fastjson.JSONObject;\n\nimport java.sql.SQLException;\nimport java.util.*;\n\n/**\n * 智联 深圳 爬虫\n * @author houyu\n * @createTime 2019/4/27 12:20\n */\n@SuppressWarnings({\"WeakerAccess\", \"Duplicates\"})\npublic class ZhiLianSZSpider implements SpiderInterface {\n\n    // 自己封装的一个网络请求工具类,\n    HttpUtil httpUtil = HttpUtil.get();\n    // 自己封装的一个公用工具类\n    EasyUtil easyUtil = EasyUtil.get();\n\n    // 定义一个标识创建一次表\n    private int iscreatetableflag = 0;\n    // 定义开始的位置\n    private int start = 0;\n    // 定义表名\n    private String tableName = \"智联深圳JAVA招聘信息\";\n\n\n    /**\n     * 处理薪资\n     * @return\n     */\n    private Object handlerSalary(){\n        List<Map<String, Object>> dataList = null;\n        try {\n            dataList = DbUtil.executeQuery(\"SELECT 薪资待遇 FROM \" + tableName);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"智联深圳java招聘信息共: \" + dataList.size() + \" 条\");\n\n        List<String> list = new ArrayList<>(dataList.size());\n        dataList.forEach((v) -> list.add((String)v.get(\"薪资待遇\")));\n\n        System.out.println(list);\n\n        List<String> tempList = new ArrayList<>(dataList.size() * 10);\n\n        list.forEach(v -> {\n            if (v.contains(\"-\")){\n                String[] split = v.split(\"-\");\n                double startNum = Double.parseDouble(split[0].replace(\"K\", \"\"));\n                double endNum = Double.parseDouble(split[1].replace(\"K\", \"\"));\n                while (startNum < endNum + 1) {\n                    double num = startNum++;\n                    String numStr = num + \"\";\n                    if (!numStr.contains(\".0\")){\n                        tempList.add(numStr);\n                    }else {\n                        tempList.add(numStr.replace(\".0\", \"\"));\n                    }\n                }\n            }else {\n                tempList.add(v);\n            }\n        });\n\n        System.out.println(tempList);\n\n        Map<String, Integer> salaryMap = easyUtil.getAloneCountInList(tempList);\n        \n        System.out.println(\"\\r\\nsalaryMap = \" + salaryMap);\n\n        return null;\n    }\n\n    /**\n     * 解析网页数据\n     * @param param\n     * @return\n     */\n    @Override\n    public Object process(Map<String, Object> param) {\n        List<Map<String, Object>> dataList = null;\n\n        while (true){\n            String html = getHtml();\n            JSONObject jsonObject = JSON.parseObject(html);\n            JSONArray jsonArray = jsonObject.getJSONObject(\"data\").getJSONArray(\"results\");\n\n            // 如果数据集合为空,跳出循环\n            if (jsonArray.isEmpty()){\n                break;\n            }\n\n            Map<String, Object> dataMap;\n            dataList = new ArrayList<>(jsonArray.size());\n\n            for (int i = 0; i < jsonArray.size(); i++) {\n                JSONObject data = jsonArray.getJSONObject(i);\n                dataMap = new HashMap<>(16);\n\n                String 更新时间 = data.getString(\"updateDate\");\n                String 结束时间 = data.getString(\"endDate\");\n                String 所属城市 = data.getJSONObject(\"city\").getString(\"display\");\n                String 详情网址 = data.getString(\"positionURL\");\n                String 福利多多 = easyUtil.join(data.getJSONArray(\"welfare\").toArray(), \",\");\n                String 薪资待遇 = data.getString(\"salary\");\n                String 工作年限 = data.getJSONObject(\"workingExp\").getString(\"name\");\n                dataMap.put(\"更新时间\", 更新时间);\n                dataMap.put(\"结束时间\", 结束时间);\n                dataMap.put(\"所属城市\", 所属城市);\n                dataMap.put(\"详情网址\", 详情网址);\n                dataMap.put(\"福利多多\", 福利多多);\n                dataMap.put(\"薪资待遇\", 薪资待遇);\n                dataMap.put(\"工作年限\", 工作年限);\n\n                String 公司代码 = data.getJSONObject(\"company\").getString(\"number\");\n                String 公司规模 = data.getJSONObject(\"company\").getJSONObject(\"size\").getString(\"name\");\n                String 公司名称 = data.getJSONObject(\"company\").getString(\"name\");\n                String 公司类型 = data.getJSONObject(\"company\").getJSONObject(\"type\").getString(\"name\");\n                String 招聘网址 = data.getJSONObject(\"company\").getString(\"url\");\n                dataMap.put(\"公司代码\", 公司代码);\n                dataMap.put(\"公司规模\", 公司规模);\n                dataMap.put(\"公司名称\", 公司名称);\n                dataMap.put(\"公司类型\", 公司类型);\n                dataMap.put(\"招聘网址\", 招聘网址);\n\n                String 岗位简介 = data.getJSONObject(\"jobType\").getString(\"display\");\n                String 招聘人数 = data.getString(\"recruitCount\");\n                String 创建时间 = data.getString(\"createDate\");\n                String 岗位名称 = data.getString(\"jobName\");\n                String 学历底线 = data.getJSONObject(\"eduLevel\").getString(\"name\");\n                String 工作制度 = data.getString(\"emplType\");\n                String 区域名称 = data.getString(\"businessArea\");\n                dataMap.put(\"岗位简介\", 岗位简介);\n                dataMap.put(\"招聘人数\", 招聘人数);\n                dataMap.put(\"创建时间\", 创建时间);\n                dataMap.put(\"岗位名称\", 岗位名称);\n                dataMap.put(\"学历底线\", 学历底线);\n                dataMap.put(\"工作制度\", 工作制度);\n                dataMap.put(\"区域名称\", 区域名称);\n\n                JSONObject positionLabel = JSON.parseObject(data.getString(\"positionLabel\"));\n                JSONArray jobLight = positionLabel.getJSONArray(\"jobLight\");\n                String 工作福利 = easyUtil.join(jobLight == null ? new String[]{} : jobLight.toArray(), \",\");\n                dataMap.put(\"工作福利\", 工作福利);\n\n                JSONArray skill = positionLabel.getJSONArray(\"skill\");\n                String 掌握技能 = easyUtil.join(skill == null ? new String[]{} : skill.toArray(), \",\");\n                dataMap.put(\"掌握技能\", 掌握技能);\n\n                System.out.println(\"dataMap = \" + dataMap);\n\n                if (iscreatetableflag == 0){\n                    DbUtil.createTable(tableName, dataMap.keySet().toArray(new String[]{}));\n                    iscreatetableflag = 1;\n                }\n                DbUtil.insertData(tableName, dataMap);\n\n                dataList.add(dataMap);\n            }\n\n            try {\n	            // 适当停顿, 避免封IP\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return dataList;\n    }\n\n    /**\n     * 网络请求数据\n     * @return\n     */\n    private String getHtml(){\n//      String url = String.format(\"https://fe-api.zhaopin.com/c/i/sou?start=%d&pageSize=90&cityId=765&kw=JAVA&kt=3\", start);\n        String url = String.format(\"https://fe-api.zhaopin.com/c/i/sou?start=%d&pageSize=90&cityId=765&kw=JAVA&kt=3&rt=134542fe834e4a019404bf10c52124b3&_v=0.04244049&x-zp-page-request-id=6d260c9fff0d4668a158babf5ae396e0-1556345376278-699243\", start);\n\n        String html = httpUtil.getHtml(url);\n        // System.out.println(html);\n        System.out.println(\"\\r\\nstart = \" + start + \"\\r\\n\");\n        start += 90;\n\n        return html;\n    }\n\n    /**\n     * main\n     */\n    public static void main(String[] args) {\n        ZhiLianSZSpider zhiLianZSSpider = new ZhiLianSZSpider();\n        //zhiLianZSSpider.process(null);\n        zhiLianZSSpider.handlerSalary();\n\n    }\n\n}\n\n```\n\n\n整体代码和中山的那个差不多, 只是添加了一个循环获取页数而已\n抓包的URL https://fe-api.zhaopin.com/c/i/sou?start=%d&pageSize=90&cityId=765&kw=JAVA&kt=3&rt=134542fe834e4a019404bf10c52124b3&_v=0.04244049&x-zp-page-request-id=6d260c9fff0d4668a158babf5ae396e0-1556345376278-699243\n这里需要注意,这里的分页没有pageIndex的概念, 而是start(开始页数), 也就是说\n默认每页90(pageSize=90)\n第一页 start 0\n第二页 start 90\n第三页 start 180\n.......\n\n\n#### 03: 观察数据并且构造数据可视化\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190427183059214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n* 数据库刚好数据为1080条, 看来数据抓取是完整的...\n* 可视化工具我使用了网上的一个小工具 http://www.olchart.com/ \n  下载好数据模板  然后处理一下数据上传上去就可以一键生成可视化图表...\n\n#### 03: 数据可视化\n\n##### 先回顾中山的薪资水平\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190427184510536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n##### 本次可视化深圳JAVA薪资水平\n\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190427184549657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n#### 重点来了, 这里不做任何评论, 看数据说话...\n\n##### 智联·中山·JAVA vs 智联·深圳·JAVA\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190427184824528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n\n结束语\n* 本次抓取智联深圳JAVA薪资水平,顺便对比一下中山的薪资\n* 其实智联广州JAVA数据也抓取了, 但是让数据可视化这方面比较耗时, 等有时间了再捣腾吧...\n* 故事尚未结束, 还是因为没有对比过其他招聘网站的数据, 我们仍然不能相信高晓松说的`上智联 你更值`这一波广告\n* 下一步, 如果有时间了抓取一个比较方便的招聘网站对比一下智联, 这个故事就算完啦...\n\n学习与交流:\nfor.houyu@qq.com\n272694308@qq.com\n\nBLOG:\nshaines.cn\n\n项目坐标:\nhttps://github.com/HouYuSource/spider\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190427185808915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n了解我的都知道,每篇博客都会上一张搞笑图片[奸笑]', '2019-04-27 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727134201831.png', NULL, 1, 1033, 1, '找时间再续爬虫啦 智联爬虫未完现续~~~\n上一篇博客获取了中山的JAVA薪资水平, 并且数据可视化, 这次主要在于获取深圳的JAVA薪资水平, 顺便和中山对比一下, 你会发现一线城市和二线城市的IT薪资差异了...  ', '爬虫,数据分析,智联招聘', '爬虫分析智联_深圳_JAVA_薪资水平(对比中山)', '20190713', 'houyu', 25);
INSERT INTO `blog` VALUES ('1150334259748184064', '1154240574968754176', 'A02_JAVA_爬虫', 0, '> 教科书版手写多线程爬虫抓取博客园首页的200页数据, 涉及多线程, 又开始考验我的JAVA线程基础啦, 还记得当初大二写一个min爬虫框架, 一多线程就挂, 各种问题, 哈哈哈    这次也算是完成一年前的一个小目标吧....\n> 上一个智联的爬虫就暂停一下, 昨天有一个朋友说觉得爬虫有点意思, 然后想尝试抓取一下, 但是遇到了不少问题, 比较经典的就是如下问题啦\n>  `\"为什么你用gradle构建项目?\"`  >> gradle是大势所趋, 国外很多项目都是gradle构建了\n>  `\"为什么你知道是这个url返回数据的\"` >> 嗯呐嗯呐, 再怎么说我也算是有一年多的爬虫经验的人(业务)才(爱好者)好嘛\n>  `\"你说url会变化, 我怎么看都是一个url, 怎么肥事?\"`  >> 我看看是什么流弊的网站先, 后面讲到\n>  `\"你抓取返回来的是JSON数据, 为什么我的带有HTML标签的?\"`  >> 这就说明这个网站接口不是绝对前后端分离啦\n> 其实我原本五一是玩一下自己的小项目的, 但是他叫我搞一下, 所以一大早起来就帮忙写一下了, 所以新故事就这么开始啦...\n\n二话不说, 昨晚他就发来一个链接https://www.cnblogs.com/, 我一看到cnblog, 咦, 这不是博客园吗?我的天, 胃口还不小, 一写爬虫就搞博客园, 博客园那里得罪你了[捂脸]\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190504110208671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n故事背景来源于一次交流...\n\n下面考虑实现的问题啦\n#### 步骤1 : 打开博客园\nhttps://www.cnblogs.com/\n\n#### 步骤2 : 浏览器抓包\n详情抓包步骤请浏览器下图, 很多细节都在图说明了, 有浏览器步骤 0 1 2 3 4等\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190504112004207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n###### 说明:\n* url : https://www.cnblogs.com/mvc/AggSite/PostList.aspx \n    - 我们就可以猜到博客园的后台是使用微软的 .NET\n* 查看请求体就知道了是JSON, 然后参数是\n {\"CategoryId\": 808, \"CategoryType\": \"SiteHome\", \"ItemListActionName\": \"PostList\", \"PageIndex\": 2, \"ParentCategoryId\": 0, \"TotalPostCount\": 4000}\n 所以改变PageIndex就是改变了页数了, 注意页数是1开始\n    - CategoryId: 808\n    - CategoryType: \"SiteHome\"\n    - ItemListActionName: \"PostList\"\n    - PageIndex: 2\n    - ParentCategoryId: 0\n    - TotalPostCount: 4000\n\n\n#### 步骤3 : 网络请求获取接口数据\n根据上一步骤, 知道了请求的实体是JSON, 那么我们就可以知道了请求的参数了, 下面就是使用我封装的一个工具类HttpUtil, \n调用\ndoPost(String url, Map<String, Object> header, int postType, Map<String, Object> body, String bodyCharset, Map<String, Object> proxy, String htmlCharset)\n具体请看源码使用\n```java\n    /**\n     * 请求网页源码\n     */\n    public String getHtml(int pageIndex){\n        System.err.println(\"正在请求页数:\" + pageIndex);\n\n        Map<String, Object> body = new HashMap<>(8);\n        String JSONStr = \"{\\\"CategoryId\\\": 808, \\\"CategoryType\\\": \\\"SiteHome\\\", \\\"ItemListActionName\\\": \\\"PostList\\\", \\\"PageIndex\\\": %d, \\\"ParentCategoryId\\\": 0, \\\"TotalPostCount\\\": 4000}\";\n        JSONStr = String.format(JSONStr, pageIndex);\n        body.put(\"JSON\", JSONStr);\n        // String url, Map<String, Object> header, int postType, Map<String, Object> body, String bodyCharset, Map<String, Object> proxy, String htmlCharset\n        String html = httpUtil.doPost(BASE_URL, DEFAULT_HEADER, HttpUtil.PostType.JSON, body, \"UTF-8\", null, \"UTF-8\");\n\n        System.out.println(html);\n        return html;\n    }\n```\n\n控制台输出\n\n```java\n<div class=\"post_item\">\n<div class=\"digg\">\n    <div class=\"diggit\" onclick=\"DiggPost(\'edison0621\',10805354,152901,1)\"> \n    <span class=\"diggnum\" id=\"digg_count_10805354\">1</span>\n    </div>\n    <div class=\"clear\"></div>\n    <div id=\"digg_tip_10805354\" class=\"digg_tip\"></div>\n</div>      \n<div class=\"post_item_body\">\n    <h3><a class=\"titlelnk\" href=\"https://www.cnblogs.com/edison0621/p/10805354.html\" target=\"_blank\">微服务探索与实践—服务注册与发现</a></h3>                 \n    <p class=\"post_item_summary\">\n<a href=\"https://www.cnblogs.com/edison0621/\" target=\"_blank\"><img width=\"48\" height=\"48\" class=\"pfs\" src=\"//pic.cnblogs.com/face/533598/20130529110206.png\" alt=\"\"/></a>    前言 微服务从大规模使用到现在已经有很多年了，从之前的探索到一步步的不断完善与成熟，微服务已经成为众多架构选择中所必须面对的一个选项。服务注册与发现是相辅相成的，所以一般会合起来思索。其依托组件有很多，比如Zookeeper,Consul，Eureka等等。 本文，我们将探讨服务注册和发现的概念及其 ...\n    </p>              \n    <div class=\"post_item_foot\">                    \n    <a href=\"https://www.cnblogs.com/edison0621/\" class=\"lightblue\">艾心❤</a> \n    发布于 2019-05-03 15:44 \n    <span class=\"article_comment\"><a href=\"https://www.cnblogs.com/edison0621/p/10805354.html#commentform\" title=\"2019-05-03 16:39\" class=\"gray\">\n        评论(1)</a></span><span class=\"article_view\"><a href=\"https://www.cnblogs.com/edison0621/p/10805354.html\" class=\"gray\">阅读(116)</a></span></div>\n</div>\n<div class=\"clear\"></div>\n</div>\n\n省略...\n\n<div class=\"post_item\">\n<div class=\"digg\">\n    <div class=\"diggit\" onclick=\"DiggPost(\'pythonista\',10803387,485203,1)\"> \n    <span class=\"diggnum\" id=\"digg_count_10803387\">0</span>\n    </div>\n    <div class=\"clear\"></div>\n    <div id=\"digg_tip_10803387\" class=\"digg_tip\"></div>\n</div>      \n<div class=\"post_item_body\">\n    <h3><a class=\"titlelnk\" href=\"https://www.cnblogs.com/pythonista/p/10803387.html\" target=\"_blank\">听说苏州是互联网的荒漠，真的吗？</a></h3>                 \n    <p class=\"post_item_summary\">\n    我国互联网存在着巨大的地域性偏差，除了北上广深杭外，其它省市的互联网都很弱小。去年 8 月，某个公众号发布了一篇《上海不相信互联网》的文章，引起了多方的讨论。CSDN 公众号以此为契机，陆续发布了关于南京、东北、西安、甚至德国等地的互联网发展情况的文章。 作为一个“苏漂”程序员，我有幸得到了 CSD ...\n    </p>              \n    <div class=\"post_item_foot\">                    \n    <a href=\"https://www.cnblogs.com/pythonista/\" class=\"lightblue\">豌豆花下猫</a> \n    发布于 2019-05-02 21:05 \n    <span class=\"article_comment\"><a href=\"https://www.cnblogs.com/pythonista/p/10803387.html#commentform\" title=\"\" class=\"gray\">\n        评论(0)</a></span><span class=\"article_view\"><a href=\"https://www.cnblogs.com/pythonista/p/10803387.html\" class=\"gray\">阅读(437)</a></span></div>\n</div>\n<div class=\"clear\"></div>\n</div>\n```\n\n#### 步骤4 : 解析HTML数据\n这里使用了Jsoup模块, 解析HTML的工具有很多, 还有很多, 我比较习惯Jsoup、htmlcleaner、XPath(webmagic封装的jsoup)\n// 导入Jsonp依赖\ncompile group: \'org.jsoup\', name: \'jsoup\', version: \'1.11.2\'\n\n代码如下:\n\n```java\n/**\n     * 解析HTML\n     */\n    public Object process(int pageIndex) {\n\n        String html = getHtml(pageIndex);\n        Document document = Jsoup.parse(html);\n        Elements post_items = document.getElementsByClass(\"post_item\");\n        post_items.forEach( v -> {\n            Element titlelnk = v.selectFirst(\".titlelnk\");\n            // 文章标题\n            String title = titlelnk.text();\n            // 详情连接\n            String href = titlelnk.attr(\"href\");\n            // 文章摘要\n            String summary = v.selectFirst(\".post_item_summary\").text();\n            // 所属作者\n            String lightblue = v.selectFirst(\".lightblue\").text();\n            // 发布时间\n            String time = v.selectFirst(\".post_item_foot\").text();\n            time = easyUtil.subStringBetween(time, \"发布于 \", \" 评论\");\n            // 评论人数\n            String comment = v.selectFirst(\".article_comment > .gray\").text();\n            comment = comment.replace(\"评论(\", \"\").replace(\")\", \"\");\n            // 阅读人数\n            String view = v.selectFirst(\".article_view > .gray\").text();\n            view = view.replace(\"阅读(\", \"\").replace(\")\", \"\");\n\n            Map<String, Object> dataMap = new LinkedHashMap<>(8);\n            dataMap.put(\"文章标题\", title);\n            dataMap.put(\"详情连接\", href);\n            dataMap.put(\"文章摘要\", summary);\n            dataMap.put(\"所属作者\", lightblue);\n            dataMap.put(\"发布时间\", time);\n            dataMap.put(\"评论人数\", comment);\n            dataMap.put(\"阅读人数\", view);\n\n            System.out.println(dataMap);\n\n            if (iscreatetableflag == 0){\n                synchronized (CnblogSpider.class){\n                    // 确保只创建一次表\n                    if (iscreatetableflag == 0){\n                        DbUtil.createTable(tableName, dataMap.keySet().toArray(new String[]{}));\n                        iscreatetableflag = 1;\n                    }\n                }\n            }\n\n            DbUtil.insertData(tableName, dataMap);\n\n        });\n\n        System.out.println(\"解析完成页数:\" + pageIndex);\n        return null;\n    }\n```\n\n控制台输出\n\n```java\n{文章标题=004-python-列表、元组、字典, 详情连接=https://www.cnblogs.com/David-domain/p/10807968.html, 文章摘要=1. 什么是列表 列表是一个可变的数据类型 列表由[]来表示, 每一项元素使用逗号隔开. 列表什么都能装. 能装对象的对象. 列表可以装大量的数据 2. 列表的索引和切片 列表和字符串一样. 也有索引和切片. 只不过切出来的内容是列表 索引的下标从0开始 [起始位置:结束位置:步长] 3. 列表的增 ..., 所属作者=do康解U, 发布时间=2019-05-04 11:26, 评论人数=0, 阅读人数=7}\n\n省略...\n\n{文章标题=物联网架构_对AWS的Greengrass的认识与理解, 详情连接=https://www.cnblogs.com/Tiancheng-Duan/p/10804804.html, 文章摘要=物联网架构_对AWS的Greengrass的认识与理解 一，前言： 这段时间有许多的收获，分析，还有总结，其中包括新系统的设计与开发，以及其中新技术的踩坑等等等。 但是最近真的很忙，项目的推进，面试工作等，尤其五月份还有考试。所以，赶紧趁着五一假期有些空暇，先发一些东西。之后，有机会再对自己的素材（ ..., 所属作者=血夜之末, 发布时间=2019-05-04 10:50, 评论人数=0, 阅读人数=26}\n```\n\n#### 步骤6 : 数据入库\n这里使用一个封装的工具类DbUtil\n\n```java\n// 表名, 数据Map, Key 对应表字段, Value 对应一行数据\nDbUtil.insertData(tableName, dataMap);\n```\n\n#### 步骤7 : 多线程并发\n这里因为页数比较多,一共200页数, 之前也有人给我留言说, 单线程, 如何提升效率, 问我能够升级一下改为多线程.\n所以这次就写一个多线程的爬虫,我个人的话如果写多线程的爬虫应该是使用webmagic, 一个参考python的scrapy的优秀框架, 非常不错, 上手也快, 多线程只需要改一个参数就可以了, 不需要考虑线程安全问题, 自己写的话难免会有小BUG\n\n我这里使用了多线程写法比较简单, 代码如下:\n\n定义实现类\n```java\nclass MyRun implements Runnable{\n\n    private int pageIndex;\n\n    public MyRun(int pageIndex) {\n        this.pageIndex = pageIndex;\n    }\n\n    @Override\n    public void run() {\n        CnblogSpider cnblogSpider = new CnblogSpider();\n        cnblogSpider.process(pageIndex);\n    }\n}\n```\n\n使用如下\n\n```java\n		// 阻塞队列固定大小\n        BlockingQueue<Runnable> queue = new ArrayBlockingQueue<Runnable>(200);\n        // 线程池\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 20, 1, TimeUnit.HOURS, queue);\n        for (int i = 1; i < 201; i++) {\n        	// 提交任务\n            executor.execute(new MyRun(i));\n        }\n        // 关闭线程池\n        executor.shutdown();\n```\n说明:我这里使用了2条核心线程数量corePoolSize, 如果需要提高线程数量, 改变corePoolSize即可, 也就是new ThreadPoolExecutor(2, ......)中的2\n\n不建议太高, 有可能会封IP的哦, 如果你有IP池的话就没问题啦, 顺便玩, 但是本着人道主义, 不建议过火啦~~~\n\n控制台输出如下:\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190504121544715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n#### 步骤8 : 数据库展示\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190504122603958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n20 * 200 = 4000\n所以看来数据没大问题, 比较顺利....\n\n#### 步骤9 : 献上整体代码\n\n```java\npackage cn.shaines.spider.module.cnblog;\n\nimport cn.shaines.spider.util.DbUtil;\nimport cn.shaines.spider.util.EasyUtil;\nimport cn.shaines.spider.util.HttpUtil;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n@SuppressWarnings(\"Duplicates\")\npublic class CnblogSpider {\n\n    /**\n     * 简单工具类\n     */\n    EasyUtil easyUtil = EasyUtil.get();\n    /**\n     * 网络请求工具类\n     */\n    HttpUtil httpUtil = HttpUtil.get();\n\n    /**\n     * POST请求的链接\n     */\n    private static final String BASE_URL = \"https://www.cnblogs.com/mvc/AggSite/PostList.aspx\";\n    /**\n     * 请求头参数\n     */\n    private static final Map<String, Object> DEFAULT_HEADER = new HashMap<>(8);\n    /**\n     * 定义一个标识创建一次表\n     */\n    private static volatile int iscreatetableflag = 0;\n    /**\n     * 定义表名\n     */\n    private String tableName = \"cnblog博客数据\";\n\n    /**\n     * 解析HTML\n     */\n    public Object process(int pageIndex) {\n\n        String html = getHtml(pageIndex);\n        Document document = Jsoup.parse(html);\n        Elements post_items = document.getElementsByClass(\"post_item\");\n        post_items.forEach( v -> {\n            Element titlelnk = v.selectFirst(\".titlelnk\");\n            // 文章标题\n            String title = titlelnk.text();\n            // 详情连接\n            String href = titlelnk.attr(\"href\");\n            // 文章摘要\n            String summary = v.selectFirst(\".post_item_summary\").text();\n            // 所属作者\n            String lightblue = v.selectFirst(\".lightblue\").text();\n            // 发布时间\n            String time = v.selectFirst(\".post_item_foot\").text();\n            time = easyUtil.subStringBetween(time, \"发布于 \", \" 评论\");\n            // 评论人数\n            String comment = v.selectFirst(\".article_comment > .gray\").text();\n            comment = comment.replace(\"评论(\", \"\").replace(\")\", \"\");\n            // 阅读人数\n            String view = v.selectFirst(\".article_view > .gray\").text();\n            view = view.replace(\"阅读(\", \"\").replace(\")\", \"\");\n\n            Map<String, Object> dataMap = new LinkedHashMap<>(8);\n            dataMap.put(\"文章标题\", title);\n            dataMap.put(\"详情连接\", href);\n            dataMap.put(\"文章摘要\", summary);\n            dataMap.put(\"所属作者\", lightblue);\n            dataMap.put(\"发布时间\", time);\n            dataMap.put(\"评论人数\", comment);\n            dataMap.put(\"阅读人数\", view);\n\n            //System.out.println(dataMap);\n\n            if (iscreatetableflag == 0){\n                synchronized (CnblogSpider.class){\n                    // 确保只创建一次表\n                    if (iscreatetableflag == 0){\n                        DbUtil.createTable(tableName, dataMap.keySet().toArray(new String[]{}));\n                        iscreatetableflag = 1;\n                    }\n                }\n            }\n\n            DbUtil.insertData(tableName, dataMap);\n        });\n\n        System.out.println(\"\\t解析完成页数:\" + pageIndex);\n        return null;\n    }\n\n    /**\n     * 请求网页源码\n     */\n    public String getHtml(int pageIndex){\n        System.err.println(\"正在请求页数:\" + pageIndex);\n\n        Map<String, Object> body = new HashMap<>(8);\n        // 这里的JSONStr是根据抓包步骤中的请求实体得知, JSON格式为{\"key1\":value, \"key2\":value}\n        String JSONStr = \"{\\\"CategoryId\\\": 808, \\\"CategoryType\\\": \\\"SiteHome\\\", \\\"ItemListActionName\\\": \\\"PostList\\\", \\\"PageIndex\\\": %d, \\\"ParentCategoryId\\\": 0, \\\"TotalPostCount\\\": 4000}\";\n        JSONStr = String.format(JSONStr, pageIndex);\n        body.put(\"JSON\", JSONStr);\n        // String url, Map<String, Object> header, int postType, Map<String, Object> body, String bodyCharset, Map<String, Object> proxy, String htmlCharset\n        String html = httpUtil.doPost(BASE_URL, DEFAULT_HEADER, HttpUtil.PostType.JSON, body, \"UTF-8\", null, \"UTF-8\");\n\n        //System.out.println(\"html = \" + html);\n        return html;\n    }\n\n    public static void main(String[] args) {\n        DEFAULT_HEADER.put(\"referer\", \"https://www.cnblogs.com/\");\n        DEFAULT_HEADER.put(\"user-agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\");\n        DEFAULT_HEADER.put(\"origin\", \"https://www.cnblogs.com\");\n        DEFAULT_HEADER.put(\"content-type\", \"application/json; charset=UTF-8\");\n\n        // 阻塞队列固定大小\n        BlockingQueue<Runnable> queue = new ArrayBlockingQueue<Runnable>(200);\n        // 线程池\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 1, TimeUnit.HOURS, queue);\n        for (int i = 1; i < 201; i++) {\n            executor.execute(new MyRun(i));\n        }\n        executor.shutdown();\n\n    }\n}\n\nclass MyRun implements Runnable{\n\n    private int pageIndex;\n\n    public MyRun(int pageIndex) {\n        this.pageIndex = pageIndex;\n    }\n\n    @Override\n    public void run() {\n        CnblogSpider cnblogSpider = new CnblogSpider();\n        cnblogSpider.process(pageIndex);\n    }\n}\n\n```\n\n\n### 结束语\n* 这里抓取了200页, 然后我尝试201页,发现返回的依旧是200页的数据, 所有有可能是后台限制了, 具体的就不探究了\n* 这里我们就可以使用这些数据啦, 比如说塞选出阅读数量和评论数据比较高的, 然后在根据标题塞选出符合自己的文章,然后就可以每天发布几篇篇优质的技术文章了呀[奸笑]\n* 这里还可以优化的就是写一个定时任务, 每隔几小时就去抓取一下, 然后入库, 甚至发布到自己的私服, 结合我之前的python wxpy, 每天定时微信发送自己几篇优质文章\n* 好玩的还有很多, 就看大家怎么玩啦...\n\n我的博客:\nhttps://www.shaines.cn\n\n讨论与交流:\nfor.houyu@qq.com\n272694308@qq.com\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190504123420779.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n\n\n\n\n\n\n\n\n\n\n', '2019-05-04 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727143529838.png', NULL, 1, 644, 1, '教科书版手写多线程爬虫抓取博客园首页的200页数据, 涉及多线程, 又开始考验我的JAVA线程基础啦, 还记得当初大二写一个min爬虫框架, 一多线程就挂, 各种问题, 哈哈哈 这次也算是完成一年前的一个小目标吧…', '爬虫,博客园', '手把手和你抓取博客园(cnblogs)的200页博客数据', '20190713', 'houyu', 10);
INSERT INTO `blog` VALUES ('1155141825550004224', '1154241584416092160', 'A07_其他', 0, '## Nginx 极简教程\n> 本项目是一个 Nginx 极简教程，目的在于帮助新手快速入门 Nginx。\n\n示例Demo：\nhttps://github.com/dunwu/nginx-tutorial/tree/master/demos\nDemo目录中的示例模拟了工作中的一些常用实战场景，并且都可以通过脚本一键式启动，让您可以快速看到演示效果。\n\n## 简介\n什么是 Nginx?\n\n**Nginx (engine x)** 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727231358824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n什么是反向代理？\n\n反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727231547496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n## Nginx 入门\n详细安装方法请参考：\nhttps://github.com/dunwu/nginx-tutorial/blob/master/install-nginx.md\nnginx 的使用比较简单，就是几条命令。\n\n常用到的命令如下：\n```js\nnginx -s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。\nnginx -s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。\nnginx -s reload     因改变了Nginx相关配置，需要重新加载配置而重载。\nnginx -s reopen     重新打开日志文件。\nnginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的。\nnginx -t            不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。\nnginx -v            显示 nginx 的版本。\nnginx -V            显示 nginx 的版本，编译器版本和配置参数。\n```\n如果不想每次都敲命令，可以在 nginx 安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下：\n```js\n@echo off\nrem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程\nnginx.exe -s stop\n\nrem 测试配置文件语法正确性\nnginx.exe -t -c conf/nginx.conf\n\nrem 显示版本信息\nnginx.exe -v\n\nrem 按照指定配置去启动nginx\nnginx.exe -c conf/nginx.conf\n```\n如果是运行在 Linux 下，写一个 shell 脚本，大同小异。\n\n## Nginx 实战\n我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。\n\n#### Http 反向代理\n我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。\n\nnginx.conf 配置文件如下：\n> 注：conf/nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件\n\n```js\n#运行用户\n#user somebody;\n\n#启动进程,通常设置成和cpu的数量相等\nworker_processes  1;\n\n#全局错误日志\nerror_log  D:/Tools/nginx-1.10.1/logs/error.log;\nerror_log  D:/Tools/nginx-1.10.1/logs/notice.log  notice;\nerror_log  D:/Tools/nginx-1.10.1/logs/info.log  info;\n\n#PID文件，记录当前启动的nginx的进程ID\npid        D:/Tools/nginx-1.10.1/logs/nginx.pid;\n\n#工作模式及连接数上限\nevents {\n    worker_connections 1024;    #单个后台worker process进程的最大并发链接数\n}\n\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp {\n    #设定mime类型(邮件支持类型),类型由mime.types文件定义\n    include       D:/Tools/nginx-1.10.1/conf/mime.types;\n    default_type  application/octet-stream;\n\n    #设定日志\n    log_format  main  \'[$remote_addr] - [$remote_user] [$time_local] \"$request\" \'\n                      \'$status $body_bytes_sent \"$http_referer\" \'\n                      \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\n\n    access_log    D:/Tools/nginx-1.10.1/logs/access.log main;\n    rewrite_log     on;\n\n    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，\n    #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #连接超时时间\n    keepalive_timeout  120;\n    tcp_nodelay        on;\n\n    #gzip压缩开关\n    #gzip  on;\n\n    #设定实际的服务器列表\n    upstream zp_server1{\n        server 127.0.0.1:8089;\n    }\n\n    #HTTP服务器\n    server {\n        #监听80端口，80端口是知名端口号，用于HTTP协议\n        listen       80;\n\n        #定义使用www.xx.com访问\n        server_name  www.helloworld.com;\n\n        #首页\n        index index.html\n\n        #指向webapp的目录\n        root D:\\01_Workspace\\Project\\github\\zp\\SpringNotes\\spring-security\\spring-shiro\\src\\main\\webapp;\n\n        #编码格式\n        charset utf-8;\n\n        #代理配置参数\n        proxy_connect_timeout 180;\n        proxy_send_timeout 180;\n        proxy_read_timeout 180;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarder-For $remote_addr;\n\n        #反向代理的路径（和upstream绑定），location 后面设置映射的路径\n        location / {\n            proxy_pass http://zp_server1;\n        }\n\n        #静态文件，nginx自己处理\n        location ~ ^/(images|javascript|js|css|flash|media|static)/ {\n            root D:\\01_Workspace\\Project\\github\\zp\\SpringNotes\\spring-security\\spring-shiro\\src\\main\\webapp\\views;\n            #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。\n            expires 30d;\n        }\n\n        #设定查看Nginx状态的地址\n        location /NginxStatus {\n            stub_status           on;\n            access_log            on;\n            auth_basic            \"NginxStatus\";\n            auth_basic_user_file  conf/htpasswd;\n        }\n\n        #禁止访问 .htxxx 文件\n        location ~ /\\.ht {\n            deny all;\n        }\n\n        #错误处理页面（可选择性配置）\n        #error_page   404              /404.html;\n        #error_page   500 502 503 504  /50x.html;\n        #location = /50x.html {\n        #    root   html;\n        #}\n    }\n}\n```\n好了，让我们来试试吧：\n* 启动 webapp，注意启动绑定的端口要和 nginx 中的 upstream 设置的端口保持一致。\n* 更改 host：在 C:\\Windows\\System32\\drivers\\etc 目录下的 host 文件中添加一条 DNS 记录127.0.0.1 www.helloworld.com\n* 启动前文中 startup.bat 的命令\n* 在浏览器中访问 www.helloworld.com，不出意外，已经可以访问了。\n\n#### Https 反向代理\n一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用 ssl 通信标准的安全 HTTP 协议）。\n\n这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点：\n* HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口\n* SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key\n\n其他和 http 反向代理基本一样，只是在 **Server** 部分配置有些不同。\n\n```js\n #HTTP服务器\n  server {\n      #监听443端口。443为知名端口号，主要用于HTTPS协议\n      listen       443 ssl;\n\n      #定义使用www.xx.com访问\n      server_name  www.helloworld.com;\n\n      #ssl证书文件位置(常见证书文件格式为：crt/pem)\n      ssl_certificate      cert.pem;\n      #ssl证书key位置\n      ssl_certificate_key  cert.key;\n\n      #ssl配置参数（选择性配置）\n      ssl_session_cache    shared:SSL:1m;\n      ssl_session_timeout  5m;\n      #数字签名，此处使用MD5\n      ssl_ciphers  HIGH:!aNULL:!MD5;\n      ssl_prefer_server_ciphers  on;\n\n      location / {\n          root   /root;\n          index  index.html index.htm;\n      }\n  }\n```\n\n#### 负载均衡\n前面的例子中，代理仅仅指向一个服务器。\n\n但是，网站在实际运营过程中，大部分都是以集群的方式运行，这时需要使用负载均衡来分流。nginx 也可以实现简单的负载均衡功能。\n\n假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台 linux 环境的服务器上。网站域名叫 www.helloworld.com，公网 IP 为 192.168.1.11。在公网 IP 所在的服务器上部署 nginx，对所有请求做负载均衡处理（下面例子中使用的是加权轮询策略）。\n\nnginx.conf 配置如下：\n```js\nhttp {\n     #设定mime类型,类型由mime.type文件定义\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n    #设定日志格式\n    access_log    /var/log/nginx/access.log;\n\n    #设定负载均衡的服务器列表\n    upstream load_balance_server {\n        #weigth参数表示权值，权值越高被分配到的几率越大\n        server 192.168.1.11:80   weight=5;\n        server 192.168.1.12:80   weight=1;\n        server 192.168.1.13:80   weight=6;\n    }\n\n   #HTTP服务器\n   server {\n        #侦听80端口\n        listen       80;\n\n        #定义使用www.xx.com访问\n        server_name  www.helloworld.com;\n\n        #对所有请求进行负载均衡请求\n        location / {\n            root        /root;                 #定义服务器的默认网站根目录位置\n            index       index.html index.htm;  #定义首页索引文件的名称\n            proxy_pass  http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表\n\n            #以下是一些反向代理的配置(可选择性配置)\n            #proxy_redirect off;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $remote_addr;\n            proxy_connect_timeout 90;          #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_send_timeout 90;             #后端服务器数据回传时间(代理发送超时)\n            proxy_read_timeout 90;             #连接成功后，后端服务器响应时间(代理接收超时)\n            proxy_buffer_size 4k;              #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\n            proxy_busy_buffers_size 64k;       #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_temp_file_write_size 64k;    #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n\n            client_max_body_size 10m;          #允许客户端请求的最大单文件字节数\n            client_body_buffer_size 128k;      #缓冲区代理缓冲用户端请求的最大字节数\n        }\n    }\n}\n```\n\n##### 负载均衡策略\nNginx 提供了多种负载均衡策略，让我们来一一了解一下：\n\n负载均衡策略在各种分布式系统中基本上原理一致，对于原理有兴趣，不妨参考：\n\n> https://dunwu.github.io/javaweb/#/theory/load-balance\n\n##### 轮询\n```js\nupstream bck_testing_01 {\n  # 默认所有服务器权重为 1\n  server 192.168.250.220:8080\n  server 192.168.250.221:8080\n  server 192.168.250.222:8080\n}\n```\n##### 加权轮询\n```js\nupstream bck_testing_01 {\n  server 192.168.250.220:8080   weight=3\n  server 192.168.250.221:8080              # default weight=1\n  server 192.168.250.222:8080              # default weight=1\n}\n```\n##### 最少连接\n```js\nupstream bck_testing_01 {\n  least_conn;\n\n  # with default weight for all (weight=1)\n  server 192.168.250.220:8080\n  server 192.168.250.221:8080\n  server 192.168.250.222:8080\n}\n```\n##### 加权最少连接\n```js\nupstream bck_testing_01 {\n  least_conn;\n\n  server 192.168.250.220:8080   weight=3\n  server 192.168.250.221:8080              # default weight=1\n  server 192.168.250.222:8080              # default weight=1\n}\n```\n##### IP Hash\n```js\nupstream bck_testing_01 {\n\n  ip_hash;\n\n  # with default weight for all (weight=1)\n  server 192.168.250.220:8080\n  server 192.168.250.221:8080\n  server 192.168.250.222:8080\n}\n```\n##### 普通 Hash\n```js\nupstream bck_testing_01 {\n\n  hash $request_uri;\n\n  # with default weight for all (weight=1)\n  server 192.168.250.220:8080\n  server 192.168.250.221:8080\n  server 192.168.250.222:8080\n}\n```\n\n#### 网站有多个 webapp 的配置\n当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。\n\n举个例子：假如 www.helloworld.com 站点有好几个 webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分:\n\nwww.helloworld.com/finance/\nwww.helloworld.com/product/\nwww.helloworld.com/admin/\n\n我们知道，http 的默认端口号是 80，如果在一台服务器上同时启动这 3 个 webapp 应用，都用 80 端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。\n\n那么，问题来了，用户在实际访问 www.helloworld.com 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。\n\n配置也不难，来看看怎么做吧：\n\n```js\nhttp {\n    #此处省略一些基本配置\n\n    upstream product_server{\n        server www.helloworld.com:8081;\n    }\n\n    upstream admin_server{\n        server www.helloworld.com:8082;\n    }\n\n    upstream finance_server{\n        server www.helloworld.com:8083;\n    }\n\n    server {\n        #此处省略一些基本配置\n        #默认指向product的server\n        location / {\n            proxy_pass http://product_server;\n        }\n\n        location /product/{\n            proxy_pass http://product_server;\n        }\n\n        location /admin/ {\n            proxy_pass http://admin_server;\n        }\n\n        location /finance/ {\n            proxy_pass http://finance_server;\n        }\n    }\n}\n```\n\n#### 静态站点\n有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。\n\n举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。\n\n配置如下：\n\n```js\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n    gzip on;\n    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;\n    gzip_vary on;\n\n    server {\n        listen       80;\n        server_name  static.zp.cn;\n\n        location / {\n            root /app/dist;\n            index index.html;\n            #转发任何请求到 index.html\n        }\n    }\n}\n```\n然后，添加 HOST：\n\n127.0.0.1 static.zp.cn\n\n此时，在本地浏览器访问 static.zp.cn ，就可以访问静态站点了。\n\n#### 搭建文件服务器\n有时候，团队需要归档一些数据或资料，那么文件服务器必不可少。使用 Nginx 可以非常快速便捷的搭建一个简易的文件服务。\n\n##### Nginx 中的配置要点：\n* 将 autoindex 开启可以显示目录，默认不开启。\n* 将 autoindex_exact_size 开启可以显示文件的大小。\n* 将 autoindex_localtime 开启可以显示文件的修改时间。\n* root 用来设置开放为文件服务的根路径。\ncharset 设置为 charset utf-8,gbk;，可以避免中文乱码问题（windows 服务器下设置后，依然乱码，本人暂时没有找到解决方法）。\n\n一个最简化的配置如下：\n\n```js\nautoindex on;# 显示目录\nautoindex_exact_size on;# 显示文件大小\nautoindex_localtime on;# 显示文件时间\n\nserver {\n    charset      utf-8,gbk; # windows 服务器下设置后，依然乱码，暂时无解\n    listen       9050 default_server;\n    listen       [::]:9050 default_server;\n    server_name  _;\n    root         /share/fs;\n}\n```\n\n#### 解决跨域\nweb 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用。\n\n各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路：\n\n* CORS\n\n  在后端服务器设置 HTTP 响应头，把你需要允许访问的域名加入 Access-Control-Allow-Origin 中。\n\n* jsonp\n\n  把后端根据请求，构造 json 数据，并返回，前端用 jsonp 跨域。\n这两种思路，本文不展开讨论。\n需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。\n举例：www.helloworld.com 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。\n前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧：\n\n\n首先，在 enable-cors.conf 文件中设置 cors ：\n\n```js\n# allow origin list\nset $ACAO \'*\';\n\n# set single origin\nif ($http_origin ~* (www.helloworld.com)$) {\n  set $ACAO $http_origin;\n}\n\nif ($cors = \"trueget\") {\n    add_header \'Access-Control-Allow-Origin\' \"$http_origin\";\n    add_header \'Access-Control-Allow-Credentials\' \'true\';\n    add_header \'Access-Control-Allow-Methods\' \'GET, POST, OPTIONS\';\n    add_header \'Access-Control-Allow-Headers\' \'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type\';\n}\n\nif ($request_method = \'OPTIONS\') {\n  set $cors \"${cors}options\";\n}\n\nif ($request_method = \'GET\') {\n  set $cors \"${cors}get\";\n}\n\nif ($request_method = \'POST\') {\n  set $cors \"${cors}post\";\n}\n```\n接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置：\n\n```js\n# ----------------------------------------------------\n# 此文件为项目 nginx 配置片段\n# 可以直接在 nginx config 中 include（推荐）\n# 或者 copy 到现有 nginx 中，自行配置\n# www.helloworld.com 域名需配合 dns hosts 进行配置\n# 其中，api 开启了 cors，需配合本目录下另一份配置文件\n# ----------------------------------------------------\nupstream front_server{\n  server www.helloworld.com:9000;\n}\nupstream api_server{\n  server www.helloworld.com:8080;\n}\n\nserver {\n  listen       80;\n  server_name  www.helloworld.com;\n\n  location ~ ^/api/ {\n    include enable-cors.conf;\n    proxy_pass http://api_server;\n    rewrite \"^/api/(.*)$\" /$1 break;\n  }\n\n  location ~ ^/ {\n    proxy_pass http://front_server;\n  }\n}\n```\n\n到此，就完成了。\n\n参考\n> http://tool.oschina.net/apidocs/apidoc?api=nginx-zh\n> http://tengine.taobao.org/book/index.html\n> https://github.com/trimstray/nginx-admins-handbook\n> https://nginxconfig.io/\n\n\n\n', '2019-07-27 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190727231358824.png', NULL, 1, 1, 1, '说明: 该篇博客为转录, 主要是我觉得写得很全面, 因为最近我也在学习nginx, 我个人感觉看了原博主的这篇的话收益会非常大, 所以特意转录原博主的该篇文章, 本意在于让更多人看到好文章, 并且从中收益。\n原文章地址  [后端技术精选](https://mp.weixin.qq.com/s/fbvncZnPhFF7lqroFt0rqQ)(转载于 后端技术精选)', 'nginx', 'Nginx 极简教程', '20190713', 'houyu', 0);
INSERT INTO `blog` VALUES ('1161971192330641408', '1154239115950747648', 'A02_JAVA', 1, '\n> 对于java, 很多开发者都说代码是成吨成吨写的; 其实, 我们也可以比较优雅的编写出高效且简约的代码的, 在这里主要介绍几个API的使用以及语法的简单入门。这些API都是基于Java8的。\n\n* java.util.stream.Stream\n	- Consumer\n	- Supplier\n	- Predicate\n	- Function\n* lambda表达式\n* java.util.Optional\n* lombok\n\n### 1.0 简单介绍一下\n**Stream**： Java 8引入了全新的**Stream** API。这里的Stream和I/O流不同，它更像具有Iterable的集合类，但行为和集合类又有所不同。\n在此最好了解一下**Consumer**、**Supplier**、**Predicate**、**Function**这几个接口的用法。\n\n**Lambda**： Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。\n\n**Optional**： Java 8引入了**Optional** 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。Optional 类的引入很好的解决空指针异常。\n\n**lombok**： Lombok可以减少很多重复代码的书写。比如说getter / setter / toString等方法的编写。\n\n### 2.0 直接上代码（以下是综合使用的简单代码）\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author houyu\n * @createTime 2019/5/23 18:14\n */\n@RestController\npublic class MainTest {\n\n    public static void main(String[] args) throws Exception {\n        // 准备数据\n        List<Student> studentList = initData();\n        /** 需求*/\n        // 1.0 获取所有姓张的同学集合(过滤)\n        List<Student> list1 = studentList.stream().filter(v -> v.getName().startsWith(\"张\")).collect(Collectors.toList());\n        System.out.println(\"获取所有姓张的同学集合list1 = \" + list1);\n        System.out.println(\"===========================================================================\");\n        // 2.0 移除重复元素,\n        List<Student> list2 = studentList.stream().distinct().collect(Collectors.toList());// 需要重写hashCode 和 equals方法\n        System.out.println(\"移除重复元素,list2 = \" + list2);\n        System.out.println(\"===========================================================================\");\n        // 3.0 移除null的元素\n        List<Student> list3 = studentList.stream().filter(Objects::nonNull).collect(Collectors.toList());\n        System.out.println(\"移除重复元素,list3 = \" + list3);\n        System.out.println(\"===========================================================================\");\n        // 4.0 获取所有学生的姓名组成一个集合\n        //List<String> list4 = studentList.stream().map(v -> v.getName()).collect(Collectors.toList());\n        List<String> list4 = studentList.stream().map(Student::getName).collect(Collectors.toList());\n        System.out.println(\"获取所有学生的姓名组成一个集合list4 = \" + list4);\n        System.out.println(\"===========================================================================\");\n        // 5.0 根据学生的年龄排序\n        //List<Student> list5 = studentList.stream().sorted((v1, v2) -> v1.getAge() - v2.getAge()).collect(Collectors.toList());\n        List<Student> list5 = studentList.stream().sorted(Comparator.comparingInt(Student::getAge)).collect(Collectors.toList());\n        System.out.println(\"根据学生的年龄排序list5 = \" + list5);\n        System.out.println(\"===========================================================================\");\n        // 6.0 统计学生的年龄\n        int ageSum = studentList.stream().filter(Objects::nonNull).map(Student::getAge).reduce(0, (sum, index) -> sum += index).intValue();\n        System.out.println(\"统计学生的年龄ageSum = \" + ageSum);\n        System.out.println(\"===========================================================================\");\n        // 7.0 转为Map, {name, age}\n        Map<String, Integer> map = studentList.stream().distinct().collect(Collectors.toMap(Student::getName, Student::getAge));\n        System.out.println(\"转为Map, {name, age}map = \" + map);\n        System.out.println(\"===========================================================================\");\n        // 8.0 打印集合每一个元素\n        studentList.stream().forEach(System.out::println);\n        System.out.println(\"===========================================================================\");\n        // 9.0 组装name字符串如: 张三,李四,王五...\n        String nameStrs = studentList.stream().map(Student::getName).collect(Collectors.joining(\",\"));\n        System.out.println(\"nameStrs = \" + nameStrs);\n        System.out.println(\"===========================================================================\");\n        // 10 扁平化\n        List<String[]> list9 = studentList.stream().map(v -> v.getName().split(\"\")).collect(Collectors.toList());\n        System.out.println(\"list9 = \" + list9);\n        List<String> list10 = studentList.stream().map(v -> v.getName().split(\"\")).flatMap(v -> Arrays.asList(v).stream())\n                .collect(Collectors.toList());\n        System.out.println(\"扁平化list10 = \" + list10);\n        System.out.println(\"===========================================================================\");\n        // 11 集合:自定义类型\n        HashSet<String> list11 = studentList.stream().map(Student::getName).collect(Collectors.toCollection(HashSet::new));\n        System.out.println(\"集合:自定义类型list11 = \" + list11);\n        System.out.println(\"===========================================================================\");\n        // 12 集合:自定义\n        List<String> list12 = studentList.stream().map(Student::getName)\n                .collect(Collectors.reducing(new ArrayList<>(), v -> Arrays.asList(v), (list, v) -> {\n                    list.addAll(v);\n                    return list;\n                }));\n        System.out.println(\"集合:自定义类型list12 = \" + list12);\n        System.out.println(\"===========================================================================\");\n        // 13 使用Optional进行判null以及链式调用\n        // 需求13, 获取集合中第一个同学的姓的汉字\n        // 普通写法如下:\n        if(studentList != null && studentList.size() > 0) {\n            Student student = studentList.get(0);\n            if(student != null) {\n                String name = student.getName();\n                if(name != null && name.length() > 0) {\n                    char c = name.charAt(0);\n                    System.out.println(\"普通写法如下:获取集合中第一个同学的姓的汉字 = \" + c);\n                }\n            }\n        }\n        System.out.println(\"===========================================================================\");\n        // 使用Optional优雅实现\n        Character character = Optional.ofNullable(studentList).map(v -> v.get(0)).map(Student::getName).filter(v -> v.length() > 0)\n                .map(v -> v.charAt(0)).orElse(null);\n        System.out.println(\"使用Optional优雅实现:获取集合中第一个同学的姓的汉字 = \" + character);\n        // 14 如果不为空则遍历打印集合中的每一个元素\n        Optional.ofNullable(studentList).ifPresent(v -> v.forEach(System.out::println));\n        System.out.println(\"===========================================================================\");\n        // 使用lambda简化代码, 其实上面也有很多使用了lambda\n        new Thread(() -> System.out.println(\"我是线程1\")){}.start();\n        System.out.println(\"===========================================================================\");\n        // 不适用lambda的形式\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"我是线程2\");\n            }\n        }){}.start();\n    }\n\n    public static List<Student> initData() {\n        return new ArrayList<>(Arrays.asList(new Student(\"张三\", 13),    //\n                                             new Student(\"李四\", 14),    //\n                                             new Student(\"王五\", 15),    //\n                                             new Student(\"张六\", 16),    //\n                                             new Student(\"李七\", 17),    //\n                                             new Student(\"王八\", 18),    //\n                                             new Student(\"李七\", 17),    // 重复\n                                             new Student(\"王八\", 18)     // 重复\n                                             // , null\n                                            , Student.builder().name(\"赵九\").age(19).build() // 使用builder创建实例, 这个实现是内部类的方式,如果需要默认值请在属性添加注解@Builder.Default,否则不生效,导致莫名BUG的哦\n\n        ));\n    }\n\n}\n\n@Data// 这里是Getter Setter toString EqualsAndHashCode\n@NoArgsConstructor// 无参构造\n@AllArgsConstructor// 全参构造\n@Builder// builder构造\nclass Student {\n\n    @Builder.Default // 如果使用builder构造的话, 需要默认值请使用@Builder.Default否则默认值无效\n    private String name = \"默认名字\";\n    private Integer age;\n}\n\n```\n\n### 3.0 lombok反编译之后的源码如下\n这样子更加有效的理解其内部实现\n\n```java\nclass Student {\n    private String name;\n    private Integer age;\n\n    private static String $default$name() {\n        return \"默认名字\";\n    }\n\n    public static Student.StudentBuilder builder() {\n        return new Student.StudentBuilder();\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public Integer getAge() {\n        return this.age;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        } else if (!(o instanceof Student)) {\n            return false;\n        } else {\n            Student other = (Student)o;\n            if (!other.canEqual(this)) {\n                return false;\n            } else {\n                Object this$name = this.getName();\n                Object other$name = other.getName();\n                if (this$name == null) {\n                    if (other$name != null) {\n                        return false;\n                    }\n                } else if (!this$name.equals(other$name)) {\n                    return false;\n                }\n\n                Object this$age = this.getAge();\n                Object other$age = other.getAge();\n                if (this$age == null) {\n                    if (other$age != null) {\n                        return false;\n                    }\n                } else if (!this$age.equals(other$age)) {\n                    return false;\n                }\n\n                return true;\n            }\n        }\n    }\n\n    protected boolean canEqual(Object other) {\n        return other instanceof Student;\n    }\n\n    public int hashCode() {\n        int PRIME = true;\n        int result = 1;\n        Object $name = this.getName();\n        int result = result * 59 + ($name == null ? 43 : $name.hashCode());\n        Object $age = this.getAge();\n        result = result * 59 + ($age == null ? 43 : $age.hashCode());\n        return result;\n    }\n\n    public String toString() {\n        return \"Student(name=\" + this.getName() + \", age=\" + this.getAge() + \")\";\n    }\n\n    public Student() {\n        this.name = $default$name();\n    }\n\n    public Student(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public static class StudentBuilder {\n        private boolean name$set;\n        private String name;\n        private Integer age;\n\n        StudentBuilder() {\n        }\n\n        public Student.StudentBuilder name(String name) {\n            this.name = name;\n            this.name$set = true;\n            return this;\n        }\n\n        public Student.StudentBuilder age(Integer age) {\n            this.age = age;\n            return this;\n        }\n\n        public Student build() {\n            String name = this.name;\n            if (!this.name$set) {\n                name = Student.$default$name();\n            }\n\n            return new Student(name, this.age);\n        }\n\n        public String toString() {\n            return \"Student.StudentBuilder(name=\" + this.name + \", age=\" + this.age + \")\";\n        }\n    }\n}\n```\n', '2019-08-15 20:01:35', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190814095753971.png', NULL, 1, 44, 1, '对于java, 很多开发者都说代码是成吨成吨写的; 其实, 我们也可以比较优雅的编写出高效且简约的代码的, 在这里主要介绍几个API的使用以及语法的简单入门。这些API都是基于Java8的。\n', '优雅编码', '如何优雅的编写java代码, 这些奇技淫巧你都知道吗', '20190713', 'houyu', 3);
INSERT INTO `blog` VALUES ('1164482650717245440', '1154239115950747648', 'A02_JAVA', 0, '\n> 作为一个爬虫业余爱好者， 网络编程是最基本的知识点，如果想玩爬虫，没有一个方便使用的网络请求工具类, 别谈什么爱好了, 业余都有点业余了, 为此, 我把我之前的一个工具类, 结合我对[面向对象]的理解封装了一下, 如果封装得不好, 有可能我对[面向对象], 有误解吧。\n> ***\n> python作为爬虫领域的语音佼佼者，其中有一个比较重要的原因就是有很多丰富简单调用的库， 比如在网络编程方面， urllib2以及requests, 以及在图表报表，语音分析等方面的第三方库也是有很多优秀的第三方库的。\n\n* 那么使用java进行网络请求(这里指的是基于http协议)是不是很难呢？其实java也提供了一个比较原生的包【java.net.*】进行网络请求， 当然也可以使用其他的第三方包，比如HttpClient、OKHttp和Volley\n\n* 但是我个人比较倾向于HttpURLConnection， 一种多用途、轻量极的HTTP客户端，使用它来进行HTTP操作可以适用于大多数的应用程序。虽然HttpURLConnection的API提供的比较简单，但是同时这也使得我们可以更加容易地去使用和扩展它。\n\n\n> 接下来我们就来看看没有封装和封装的差异在哪吧\n\n### util形式的封装(参数过多, 使用不方便, 不易于重构等问题)\n```java\n// 封装的方法\n/**\n * POST请求\n * @param urlString url\n * @param requestHeader 请求头参数\n * @param requestBody 请求体\n * @param requestBodyType POST请求体类型  : \n *  <br>    1:HttpUtils.PostType.FORM_DATA\n *  <br>    2:HttpUtils.PostType.JSON_DATA (tip:最简单的方式 >> requestBody.put(\"SEND_DATA\",JSONString))\n * @param requestBodyCharset 请求体编码\n * @param htmlCharset 网页编码\n * @param connectionType 连接类型 : \n *  <br>    1:HttpUtils.ConnectionType.HTTP_URL_CONNECTION\n *  <br>    2:HttpUtils.ConnectionType.HTTP_CLIENT\n * @param proxy 代理对象 : HttpUtils.get().setProxy(host, port, useName, password)\n * @return\n */\npublic String doPost(String urlString, Map<String, Object> requestHeader, Map<String, Object> requestBody, int requestBodyType, String requestBodyCharset, String htmlCharset, int connectionType, Proxy proxy) {\n	// ...\n}\n    \n// 调用者\nString url = \"https://www.baidu.com\";\n//\nMap<String, Object> header = new HashMap(8);\nheader.put(\"Accept-Encoding\", \"gzip, deflate, br\");\nheader.put(\"Referer\", \"https://www.baidu.com\");\nheader.put(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3722.400 QQBrowser/10.5.3771.400\");\nheader.put(\"Accept\", \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01\");\n//\nString htmlCharset = \"UTF-8\";\n//\nMap<String, Object> body = new HashMap(8);\nbody.put(\"Accept-Encoding\", \"gzip, deflate, br\");\nbody.put(\"Referer\", \"https://www.baidu.com\");\nbody.put(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3722.400 QQBrowser/10.5.3771.400\");\nbody.put(\"Accept\", \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01\");\n// \n// requestBodyCharset, \n// String htmlCharset, \n// int connectionType, \n// Proxy proxy\n\ndoPost(url, header,body ,HttpUtils.PostType.FORM_DATA, ......);\n\n```\n\n### 基于面向对象简单封装一下(支持默认值, 支持链式编程等, 好处多多...)\n下面就是简单使用的一个demo\n```java\nString body = HttpUtil.builder(\"https://www.baidu.com\")\n                .addHead(\"Referer\", \"https://www.baidu.com\")// 添加头信息\n                .addHead(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3722.400 QQBrowser/10.5.3771.400\")//\n                .execute()// 执行请求\n                .getBodyString();// 获取响应\n```\n是不是一下子感觉很舒服?\n\n#### 这个工具类我花了好长时间整理出来的, 是我一直以来的xxx.xxx.xxx.util.http包啊[捂脸]\n封装的过程中借鉴了很多优秀文章, debug了不少源码\n* hutool\n* https://github.com/guozhengXia/UrlHttpUtils.\n...\n\n\n#### 封装了这个这个工具类那么辛苦都有些什么骚操作呢?\n* 原生 / 无依赖 / 超轻量\n* 8级重定向(理论可以无限极)\n* 重定向url记录\n* 甜品链式调用(就好像吃甜品一样, 甜甜的,很舒服)\n* 高效率请求(和网站以及自己网络有关, 我试过200个请求https://www.sogou.com/ 平均21ms一个请求, 速度超级快)\n* 可设置代理(主要用于爬虫)\n* 自动识别html响应编码(可以手动设置)\n* 自动补全url(比如:baidu.com => http://baidu.com)\n* api调用极其简单\n* cookie管理(主要用于爬虫以及登录等操作)\n* 支持restful接口请求\n* 信任所有https站点(只要该站点不需要双向证书, 你都可以很愉快的玩, 也保留参数hostnameVerifier sslSocketFactory进行设置)\n* 所有的操作都是低加载\n* 一个类走天下, 封装对象都是static类, 总代码量一个900+行, 其中也是用了一些奇技淫巧的骚操作。\n\n#### 主要有以下几个类\n\n```java\n/**\n * @description 请求对象\n * @date 2018-08-18 10:10:13\n * @author houyu for.houyu@foxmail.com\n */\npublic static class Request {}\n\n/**\n * @description 响应对象\n * @date 2018-08-18 10:10:13\n * @author houyu for.houyu@foxmail.com\n */\npublic static class Response {}\n\n/**\n * @description 代理对象\n * @date 2018-08-18 10:10:13\n * @author houyu for.houyu@foxmail.com\n */\npublic static class Proxy {}\n\n/**\n * @description 请求方法\n * @date 2018-08-18 10:10:13\n * @author houyu for.houyu@foxmail.com\n */\npublic enum Method {GET, POST, PUT, DELETE}\n\n/**\n * @description 常量\n * @date 2018-08-18 10:10:13\n * @author houyu for.houyu@foxmail.com\n */\npublic interface Constant {}\n\n```\n\n#### 主要API\n请求API\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190822190603943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n响应API\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190822190632300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n#### 源码部分\n\n```java\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.X509Certificate;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.StringJoiner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\n/**\n * @description: 网络请求工具类\n * @author: houyu for.houyu@foxmail.com\n * @create: 2018-08-18 09:10:13\n */\npublic class HttpURLConnectionUtil {\n\n    public static Request builder(String site) {\n        return new Request(site);\n    }\n\n    public static Request builderPost(String site) {\n        return new Request(site).setMethod(Method.POST);\n    }\n\n    public static boolean isEmpty(Object o) {\n        return null == o || (o instanceof String && ((String) o).length() == 0);\n    }\n\n    public static boolean nonEmpty(Object o) {\n        return !isEmpty(o);\n    }\n\n    /**\n     * @description 请求对象\n     * @date 2019-08-21 11:00:49\n     * @author houyu for.houyu@foxmail.com\n     */\n    public static class Request {\n\n        private String site;                                // 请求网站地址\n        private Method method = Method.GET;                 // 请求方法(默认是GET)\n        private Map<String, Object> header;                 // 请求头\n        private Map<String, Object> param;                  // 请求参数\n        private Map<String, Object> extra;                  // 携带参数(可使用于响应之后的操作)\n        private Proxy proxy;                                // 代理\n        private String charset = Constant.UTF_8;            // 参数编码(默认UTF-8)\n        private boolean ifEncodeUrl = false;                // 是否编码URL\n        private boolean ifCache = false;                    // 是否缓存\n        private String json;                                // JSON文本\n        private int timeout = -1;                           // 连接超时(单位:毫秒)\n        private String cookie;                              // 携带cookie(优先) ex: key1=val1; key2=val2\n        private boolean ifStableRedirection = true;         // 是否稳定重定向\n        private List<String> redirectUrlList;               // 重定向的url列表\n        private HttpURLConnection http = null;              // HttpURLConnection对象\n        private HostnameVerifier hostnameVerifier;          // 主机名验证程序\n        private SSLSocketFactory sslSocketFactory;          // SocketFactory\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        private static Map<String, Object> DEFAULT_HEADER;  // 默认的请求头\n        private static HostnameVerifier HOSTNAME_VERIFIER;  // 设置主机名验证程序\n        private static SSLSocketFactory SSL_SOCKET_FACTORY; // SocketFactory\n\n        static {\n            /** 初始化默认请求头 */\n            DEFAULT_HEADER = new HashMap<>(8);\n            DEFAULT_HEADER.put(\"Accept\", \"text/html,application/xhtml+xml,application/xml,application/json;q=0.9,*/*;q=0.8\");\n            DEFAULT_HEADER.put(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36 Hutool\");\n            DEFAULT_HEADER.put(\"Accept-Encoding\", \"gzip\");\n            DEFAULT_HEADER.put(\"Accept-Language\", \"zh-CN,zh;q=0.8\");\n            // DEFAULT_HEADER.put(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            //\n            DEFAULT_HEADER = Collections.unmodifiableMap(DEFAULT_HEADER); // 设置不可以修改\n            //\n            /** 初始化全局主机名验证程序 */\n            HOSTNAME_VERIFIER = (s, sslSession) -> true;\n            /** 初始化全局主机名验证程序 */\n            SSLContext sslContext = null;\n            try {\n                sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(null, new TrustManager[] {new X509TrustManager() {\n                    @Override\n                    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) {\n                    }\n\n                    @Override\n                    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) {\n                    }\n\n                    @Override\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return new X509Certificate[0];\n                    }\n                }}, new SecureRandom());\n            } catch(NoSuchAlgorithmException | KeyManagementException e) {\n                e.printStackTrace();\n            }\n            SSL_SOCKET_FACTORY = sslContext.getSocketFactory();\n            //\n        }\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        public Request(String site) {\n            this.site = site;\n        }\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        /** 执行 请求 */\n        public Response execute() {\n            // 初始化GET param\n            this.handleGETParamWithUrl();\n            // 初始化连接\n            this.initConnection();\n            // 发送数据包裹\n            this.send();\n            // 处理重定向\n            boolean ifRedirect = this.handleRedirect();\n            if(ifRedirect) {\n                return this.execute();// 递归实现重定向\n            }\n            // 返回响应\n            return new Response(this.http, this.redirectUrlList, this.extra);\n        }\n\n        /** 处理重定向 */\n        private boolean handleRedirect() {\n            if(this.ifStableRedirection) {\n                // 采用稳定重定向方式, 需要处理重定向问题\n                int responseCode;\n                try {\n                    responseCode = this.http.getResponseCode();\n                } catch(IOException var3) {\n                    responseCode = 0;\n                }\n                if(responseCode == Constant.REDIRECT_CODE_301 || responseCode == Constant.REDIRECT_CODE_302\n                        || responseCode == Constant.REDIRECT_CODE_303) {\n                    this.site = this.http.getHeaderField(Constant.LOCATION);\n                    this.redirectUrlList = this.redirectUrlList == null ? new ArrayList<>(8) : this.redirectUrlList;\n                    this.redirectUrlList.add(this.site);\n                    if(this.redirectUrlList.size() < 8) {\n                        this.http.disconnect();     // 断开本次连接, 然后重新请求\n                        return true;\n                    }\n                }\n            } else {\n                // 使用默认的重定向规则处理, 无序手动处理, 但是有可能出现重定向失败\n                // do non thing\n            }\n            return false;\n        }\n\n        /** 发送数据 */\n        private void send() {\n            try {\n                if(!Method.POST.equals(this.method) && !Method.PUT.equals(this.method)) {\n                    this.http.connect();\n                } else {\n                    // POST...\n                    this.handleContentTypeAndBody();\n                }\n            } catch(IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        /** 处理 ContentType 和 传输内容 */\n        private void handleContentTypeAndBody() throws IOException {\n            if(!Method.GET.equals(this.method)) {\n                // non GET\n                /* handle ContentType */\n                String contentType = Objects.toString(this.header.get(Constant.CONTENT_TYPE), null);\n                if(contentType == null) {\n                    // 没有 Content-Type\n                    if(this.json != null) {\n                        this.addAndRefreshHead(Constant.CONTENT_TYPE, Constant.CONTENT_TYPE_WITH_JSON + this.charset);\n                    } else {\n                        this.addAndRefreshHead(Constant.CONTENT_TYPE, Constant.CONTENT_TYPE_WITH_FORM + this.charset);\n                    }\n                } else {\n                    if(!contentType.contains(Constant.CHARSET)) {\n                        // 存在 Content-Type ,没有 ;charset, 处理方式是添加 ;charset=this.charset\n                        this.addAndRefreshHead(Constant.CONTENT_TYPE, contentType + \"; \" + Constant.CONTENT_TYPE_WITH_CHARSET + this.charset);\n                    }\n                }\n                // 需要重新赋值一下, 否则导致下面有 NPE 危险\n                contentType = String.valueOf(this.header.get(Constant.CONTENT_TYPE));\n                /* handle body */\n                boolean ifJson = contentType.contains(\"json\");\n                byte[] body;\n                if(ifJson) {\n                    if(this.json != null) {\n                        body = this.json.getBytes(this.charset);\n                    } else {\n                        // can handle param to json\n                        body = new byte[0];\n                    }\n                } else {\n                    //\n                    String paramString = parseParamMapToString(this.param, this.charset);// 必须编码, 否则个别网站获取不到数据\n                    paramString = Objects.toString(paramString, \"\");\n                    body = paramString.getBytes(this.charset);\n                }\n                try(OutputStream outputStream = this.http.getOutputStream()) {\n                    // 使用 try-resource 方式处理流, 无需手动关闭流操作\n                    outputStream.write(body);\n                    outputStream.flush();\n                }\n            }\n        }\n\n        /** 初始化连接 */\n        private void initConnection() throws RuntimeException {\n            URL url;\n            try {\n                url = new URL(this.site);\n            } catch(MalformedURLException e) {\n                throw new RuntimeException(\"创建URL出错\" + e.getMessage());\n            }\n            //\n            try {\n                this.http = this.openConnection(url, this.proxy);\n                //\n                if(this.timeout > 0) {\n                    // 设置超时\n                    this.http.setConnectTimeout(this.timeout);\n                    this.http.setReadTimeout(this.timeout);\n                }\n                // 设置请求方法\n                this.method = this.method == null ? Method.GET : this.method;\n                this.http.setRequestMethod(this.method.name());\n            } catch(IOException e) {\n                throw new RuntimeException(\"打开连接出错\" + e.getMessage());\n            }\n            //\n            this.http.setDoInput(true);\n            if(!Method.GET.equals(this.method)) {\n                // 非GET方法需要设置可输入\n                http.setDoOutput(true);\n                http.setUseCaches(false);\n            }\n            // 初始化设置默认请求头\n            this.initAndSetDefaultHeader();\n            //\n            if(this.cookie != null) {\n                // 设置cookie\n                this.setCookie();\n            }\n            // 设置缓存\n            if(ifCache) {\n                this.http.setUseCaches(true);\n            }\n            // 设置是否自动重定向\n            this.http.setInstanceFollowRedirects(!(this.ifStableRedirection));\n        }\n\n        /** 设置 Cookie到连接中 */\n        private void setCookie() {\n            if(HttpURLConnectionUtil.nonEmpty(this.cookie)) {\n                this.addAndRefreshHead(Constant.REQUEST_COOKIE, this.cookie);\n            }\n        }\n\n        /** 刷新 请求头信息 */\n        private void addAndRefreshHead(String key, Object value) {\n            this.addHead(key, value);\n            http.setRequestProperty(key, String.valueOf(value));\n        }\n\n        /** 初始化和设置默认请求头 */\n        private void initAndSetDefaultHeader() {\n            HashMap<String, Object> initMap = new HashMap<>(16);\n            initMap.putAll(DEFAULT_HEADER);\n            if(this.header != null) {\n                initMap.putAll(this.header);\n            }\n            this.header = initMap;\n            this.header.forEach((k, v) -> this.http.setRequestProperty(k, String.valueOf(v)));\n        }\n\n        /** 打开连接 */\n        private HttpURLConnection openConnection(URL url, Proxy proxy) throws IOException {\n            URLConnection connection;\n            if(this.proxy == null) {\n                connection = url.openConnection();\n            } else if(HttpURLConnectionUtil.nonEmpty(proxy.getUsername())) {                            // 设置代理服务器\n                java.net.Proxy javaNetProxy = new java.net.Proxy(java.net.Proxy.Type.HTTP, new InetSocketAddress(this.proxy.getHost(), this.proxy.getPort()));\n                connection = url.openConnection(javaNetProxy);\n                String authString = this.proxy.getUsername() + \":\" + this.proxy.getPassword();\n                String auth = \"Basic \" + Base64.getEncoder().encodeToString(authString.getBytes(this.charset));\n                connection.setRequestProperty(Constant.PROXY_AUTHORIZATION, auth);\n            } else if(HttpURLConnectionUtil.nonEmpty(proxy.getHost())) {                                // 设置代理主机和端口\n                java.net.Proxy javaNetProxy = new java.net.Proxy(java.net.Proxy.Type.HTTP, new InetSocketAddress(this.proxy.getHost(), this.proxy.getPort()));\n                connection = url.openConnection(javaNetProxy);\n            } else {                                                                                // 不设置代理\n                connection = url.openConnection();\n            }\n            if(connection instanceof HttpsURLConnection) {\n                HttpsURLConnection httpsConn = (HttpsURLConnection) connection;\n                httpsConn.setHostnameVerifier(this.hostnameVerifier == null ? HOSTNAME_VERIFIER : this.hostnameVerifier);   // 设置主机名验证程序\n                httpsConn.setSSLSocketFactory(this.sslSocketFactory == null ? SSL_SOCKET_FACTORY : this.sslSocketFactory);      // 设置ssl factory\n            }\n            return (HttpURLConnection) connection;\n        }\n\n        /** 设置 如果是GET, 则将参数写入url中 */\n        private void handleGETParamWithUrl() {\n            // 校验url地址\n            Objects.requireNonNull(this.site, \"网站地址不可以为空\");\n            // 校验url协议 要求url必须是http / https协议, 默认使用http协议\n            if(!this.site.toLowerCase().startsWith(Constant.HTTP)) {\n                this.site = Constant.HTTP + \"://\" + this.site;\n            }\n            if(Method.GET.equals(this.method)) {\n                String query = parseParamMapToString(this.param, ifEncodeUrl ? this.charset : null);\n                if(query != null) {\n                    this.site = this.site.contains(\"?\") ? (this.site + \"&\" + query) : (this.site + \"?\" + query);\n                }\n            }\n        }\n\n        /**\n         * @description Map => key1=val1&key2=val2\n         * @date 2019-08-20 20:42:59\n         * @author houyu for.houyu@foxmail.com\n         */\n        public static String parseParamMapToString(Map<String, Object> paramMap, String charset) {\n            if(paramMap != null && paramMap.size() > 0) {\n                StringBuilder builder = new StringBuilder(128);\n                if(charset == null) {\n                    paramMap.forEach((k, v) -> builder.append(k).append(Constant.EQU).append(v).append(Constant.AND_SIGN));// key1=val1&key2=val2\n                } else {\n                    paramMap.forEach((k, v) -> builder.append(encode(k, charset)).append(Constant.EQU).append(encode(String.valueOf(v), charset))\n                            .append(Constant.AND_SIGN));\n                }\n                return builder.delete(builder.length() - 1, builder.length()).toString();\n            }\n            return null;\n        }\n\n        /** url 编码 */\n        public static String encode(String text, String charset) {\n            if(text != null && Charset.isSupported(charset)) {\n                // 不为空 并且charset可用\n                try {\n                    return URLEncoder.encode(text, charset);\n                } catch(UnsupportedEncodingException e) {\n                    // do non thing\n                }\n            }\n            return text;\n        }\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        /** 设置 网站地址 */\n        public Request setSite(String site) {\n            this.site = site;\n            return this;\n        }\n\n        /** 设置 请求方法 */\n        public Request setMethod(Method method) {\n            this.method = method;\n            return this;\n        }\n\n        /** 设置 请求头 */\n        public Request setHeader(Map<String, Object> header) {\n            this.header = header;\n            return this;\n        }\n\n        /** 设置 请求参数 */\n        public Request setParam(Map<String, Object> param) {\n            this.param = param;\n            return this;\n        }\n\n        /** 设置 携带参数 */\n        public Request setExtra(Map<String, Object> extra) {\n            this.extra = extra;\n            return this;\n        }\n\n        /** 设置 参数编码 */\n        public Request setCharset(String charset) {\n            if(Charset.isSupported(charset)) {\n                // 只设置支持的编码, 否则有可能导致整体的错误\n                this.charset = charset;\n            }\n            return this;\n        }\n\n        /** 设置 是否需要编码 */\n        public Request setIfEncodeUrl(boolean ifEncodeUrl) {\n            this.ifEncodeUrl = ifEncodeUrl;\n            return this;\n        }\n\n        /** 设置 是否缓存 */\n        public Request setIfCache(boolean ifCache) {\n            this.ifCache = ifCache;\n            return this;\n        }\n\n        /** 设置 JSON文本 */\n        public Request setJson(String json) {\n            this.json = json;\n            return this;\n        }\n\n        /** 设置 连接超时 */\n        public Request setTimeout(int timeout) {\n            this.timeout = timeout;\n            return this;\n        }\n\n        /** 设置 携带cookie */\n        public Request setCookie(String cookie) {\n            this.cookie = cookie;\n            return this;\n        }\n\n        /** 设置 携带cookie */\n        public Request setCookie(Map<String, String> cookie) {\n            StringBuilder builder = new StringBuilder(128);\n            cookie.forEach((k, v) -> builder.append(k).append(Constant.EQU).append(v).append(Constant.COOKIE_SPLIT));\n            return this.setCookie(builder.toString());\n        }\n\n        /** 设置 是否稳定重定向 */\n        public Request setIfStableRedirection(boolean ifStableRedirection) {\n            this.ifStableRedirection = ifStableRedirection;\n            return this;\n        }\n\n        /** 添加 请求头 */\n        public Request addHead(String key, Object value) {\n            this.header = this.header == null ? new HashMap<>(8) : this.header;\n            this.header.put(key, value);\n            return this;\n        }\n\n        /** 添加 请求参数 */\n        public Request addParam(String key, Object value) {\n            this.param = this.param == null ? new HashMap<>(16) : this.param;\n            this.param.put(key, value);\n            return this;\n        }\n\n        /** 添加 携带参数 */\n        public Request addExtra(String key, Object value) {\n            this.extra = this.extra == null ? new HashMap<>(16) : this.extra;\n            this.extra.put(key, value);\n            return this;\n        }\n\n        /** 设置 代理 */\n        public Request setProxy(String host, Integer port) {\n            this.proxy = this.proxy == null ? new Proxy(host, port) : this.proxy;\n            return this;\n        }\n\n        /** 设置 代理 */\n        public Request setProxy(String host, Integer port, String username, String password) {\n            this.proxy = this.proxy == null ? new Proxy(host, port, username, password) : this.proxy;\n            return this;\n        }\n\n        /** 设置 主机名验证程序 */\n        public Request setHostnameVerifier(HostnameVerifier hostnameVerifier) {\n            this.hostnameVerifier = hostnameVerifier;\n            return this;\n        }\n\n        /** 设置 sslSocketFactory */\n        public Request setSslSocketFactory(SSLSocketFactory sslSocketFactory) {\n            this.sslSocketFactory = sslSocketFactory;\n            return this;\n        }\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        /** 获取 网站地址 */\n        public String getSite() {\n            return this.site;\n        }\n\n        /** 获取 请求方法 */\n        public Method getMethod() {\n            return this.method;\n        }\n\n        /** 获取 请求头 */\n        public Map<String, Object> getHeader() {\n            return this.header;\n        }\n\n        /** 获取 请求参数 */\n        public Map<String, Object> getParam() {\n            return this.param;\n        }\n\n        /** 获取 携带参数 */\n        public Map<String, Object> getExtra() {\n            return this.extra;\n        }\n\n        /** 获取 代理 */\n        public Proxy getProxy() {\n            return this.proxy;\n        }\n\n        /** 获取 参数编码 */\n        public String getCharset() {\n            return this.charset;\n        }\n\n        /** 获取 JSON文本 */\n        public String getJson() {\n            return this.json;\n        }\n\n        /** 获取 连接超时 */\n        public int getTimeout() {\n            return this.timeout;\n        }\n\n        /** 获取 是否稳定重定向 */\n        public boolean getIfStableRedirection() {\n            return this.ifStableRedirection;\n        }\n\n        /** 获取 主机名验证程序 */\n        public HostnameVerifier getHostnameVerifier() {\n            return this.hostnameVerifier;\n        }\n\n        /** 获取 sslSocketFactory */\n        public SSLSocketFactory getSslSocketFactory() {\n            return this.sslSocketFactory;\n        }\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    }\n\n    /**\n     * @description 响应对象\n     * @date 2019-08-21 11:01:03\n     * @author houyu for.houyu@foxmail.com\n     */\n    public static class Response {\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        private String site;                                // 请求url\n        private Map<String, List<String>> header;           // 响应头信息\n        private Map<String, Object> extra;                  // request携带参数(可使用于响应之后的操作)\n        private String cookie;                              // cookie ex:key2=val2; key1=val1\n        private String charset;                             // 响应编码\n        private String defaultCharset;                      // 默认编码\n        private byte[] body;                                // 响应体\n        private List<String> redirectUrlList;               // 重定向的url列表\n        private HttpURLConnection http;                     // HttpURLConnection\n        private Integer code;                               // http响应状态码(HttpURLConnection.HTTP_OK)\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        /** 私有化构造 */\n        protected Response() {}\n\n        /** 获取html 响应的 charset */\n        private static final Pattern PATTERN_FOR_CHARSET = Pattern.compile(\"charset\\\\s*=\\\\s*[\'\\\"]*([^\\\\s;\'\\\"]*)\", Pattern.CASE_INSENSITIVE);\n        private static Response EMPTY_RESPONSE;\n\n        static {\n            EMPTY_RESPONSE = new Response();\n            EMPTY_RESPONSE.site = Constant.EMPTY_STRING;\n            EMPTY_RESPONSE.header = Collections.emptyMap();\n            EMPTY_RESPONSE.extra = Collections.emptyMap();\n            EMPTY_RESPONSE.cookie = Constant.EMPTY_STRING;\n            EMPTY_RESPONSE.charset = Constant.UTF_8;\n            EMPTY_RESPONSE.defaultCharset = Constant.UTF_8;\n            EMPTY_RESPONSE.body = new byte[0];\n            EMPTY_RESPONSE.redirectUrlList = Collections.emptyList();\n            EMPTY_RESPONSE.http = null;\n            EMPTY_RESPONSE.code = 0;\n        }\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        /** 构造 Response */\n        protected Response(HttpURLConnection http, List<String> redirectUrlList, Map<String, Object> extra) {\n            //\n            this.http = http;\n            this.redirectUrlList = redirectUrlList;\n            this.extra = extra;\n            //\n            this.init();\n        }\n\n        /** 初始化数据 */\n        private void init() {\n            try {\n                this.site = this.http.getURL().toString();\n                this.header = this.http.getHeaderFields();\n                this.code = this.http.getResponseCode();\n                this.defaultCharset = detectCharset(this.http.getContentType());\n                InputStream inputStream = this.code < 400 ? this.http.getInputStream() : this.http.getErrorStream();\n                this.initParseInputSteam(inputStream);\n            } catch(IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        /** 初始化解析inputStream */\n        private void initParseInputSteam(InputStream inputStream) throws IOException {\n            // 获取响应头是否有Content-Encoding=gzip\n            String gzip = Optional.ofNullable(this.header.get(Constant.CONTENT_ENCODING))//\n                    .filter(v -> v.size() > 0)//\n                    .map(v -> v.get(0))//\n                    .map(String::toLowerCase)//\n                    .filter(Constant.GZIP::equals).orElse(null);\n            if(gzip != null) {\n                inputStream = new GZIPInputStream(inputStream);\n            }\n            ByteArrayOutputStream outputStream = null;\n            try {\n                outputStream = new ByteArrayOutputStream();\n                byte[] bytes = new byte[1024 * 3];\n                for(int length = 0; length > -1; length = inputStream.read(bytes)) {\n                    outputStream.write(bytes, 0, length);\n                    outputStream.flush();\n                }\n                this.body = outputStream.toByteArray();\n            } catch(IOException e) {\n                throw new RuntimeException(e);\n            } finally {\n                this.close(inputStream);\n                this.close(outputStream);\n                this.http.disconnect();\n            }\n        }\n\n        private void close(Closeable closeable) {\n            try {\n                if(closeable != null) {\n                    closeable.close();\n                }\n            } catch(IOException e) {\n                // non do thing\n            } finally {\n                closeable = null;\n            }\n        }\n\n        /*public static Response ofEmpty() {\n            return Response.EMPTY_RESPONSE;\n        }*/\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        /** 获取 url链接 */\n        public String getSite() {\n            return this.site;\n        }\n\n        /** 获取 响应头信息 */\n        public Map<String, List<String>> getHeader() {\n            return this.header;\n        }\n\n        /** 获取 携带参数 */\n        public Map<String, Object> getExtra() {\n            return this.extra;\n        }\n\n        /** 获取 携带参数值 */\n        public Object getExtraValue(String key) {\n            return this.extra == null ? null : this.extra.get(key);\n        }\n\n        /** 获取 cookie */\n        public String getCookie() {\n            if(this.cookie == null) {\n                List<String> cookieList = this.header.get(Constant.RESPONSE_COOKIE);\n                if(cookieList != null) {\n                    StringJoiner joiner = new StringJoiner(Constant.COOKIE_SPLIT);\n                    for(String cookieObj : cookieList) {\n                        joiner.add(cookieObj.split(Constant.COOKIE_SPLIT)[0]);\n                    }\n                    this.cookie = joiner.toString();\n                }\n            }\n            return this.cookie;\n        }\n\n        /** 获取 cookieMap */\n        public Map<String, String> getCookieMap() {\n            Map<String, String> cookieMap = null;\n            String cookieString = this.getCookie();\n            if(cookieString != null) {\n                String[] cookieKeyValArray = cookieString.split(Constant.COOKIE_SPLIT);\n                cookieMap = new HashMap<>(cookieKeyValArray.length);\n                for(String cookieKeyVal : cookieKeyValArray) {\n                    String[] keyVal = cookieKeyVal.split(Constant.EQU, 2);\n                    if(keyVal.length == 2) {\n                        cookieMap.put(keyVal[0], keyVal[1]);\n                    }\n                }\n            }\n            return cookieMap;\n        }\n\n        /** 获取 html编码 */\n        public String getCharset() {\n            return this.charset == null ? this.defaultCharset : this.charset;\n        }\n\n        /** 获取 响应 */\n        public byte[] getBody() {\n            return this.body;\n        }\n\n        /** 获取 响应 */\n        public String getBodyString() {\n            try {\n                return getBodyString(this.charset == null ? this.defaultCharset : this.charset);\n            } catch(UnsupportedEncodingException e) {\n                return null;\n            }\n        }\n\n        /** 获取 响应 */\n        public String getBodyString(String charset) throws UnsupportedEncodingException {\n            return new String(this.getBody(), Charset.isSupported(charset) ? charset : this.getCharset());\n        }\n\n        /** 获取 重定向的url列表 */\n        public List<String> getRedirectUrlList() {\n            return this.redirectUrlList;\n        }\n\n        public HttpURLConnection getHttp() {\n            return this.http;\n        }\n\n        public Integer getCode() {\n            return this.code;\n        }\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        /** 自动识别网页编码 */\n        private static String detectCharset(String contentType) {\n            // contentType = text/html\n            // contentType = text/html;charset=ISO-8859-1\n            if(contentType != null) {\n                int index = contentType.indexOf(Constant.CONTENT_TYPE_WITH_CHARSET);\n                if(index > 0) {\n                    String parseCharset = contentType.substring(index + Constant.CONTENT_TYPE_WITH_CHARSET.length()).trim();\n                    if(Charset.isSupported(parseCharset)) {\n                        return parseCharset;\n                    }\n                    Matcher matcher = PATTERN_FOR_CHARSET.matcher(contentType);\n                    if(matcher.find()) {\n                        parseCharset = matcher.group(1);\n                        if(Charset.isSupported(parseCharset)) {\n                            return parseCharset;\n                        }\n                    }\n                }\n            }\n            return Constant.UTF_8;\n        }\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    }\n\n    /**\n     * @description 代理对象\n     * @date 2019-08-21 11:00:30\n     * @author houyu for.houyu@foxmail.com\n     */\n    public static class Proxy {\n\n        private String host;\n        private Integer port;\n        private String username;\n        private String password;\n\n        public Proxy(String host, Integer port) {\n            this.host = host;\n            this.port = port;\n        }\n\n        public Proxy(String host, Integer port, String username, String password) {\n            this.host = host;\n            this.port = port;\n            this.username = username;\n            this.password = password;\n        }\n\n        public String getHost() {\n            return host;\n        }\n\n        public Integer getPort() {\n            return port;\n        }\n\n        public String getUsername() {\n            return username;\n        }\n\n        public String getPassword() {\n            return password;\n        }\n\n    }\n\n    /**\n     * @description 请求方法\n     * @date 2019-08-21 11:00:17\n     * @author houyu for.houyu@foxmail.com\n     */\n    public enum Method {GET, POST, PUT, DELETE}\n\n    /**\n     * @description 常量\n     * @date 2019-08-21 10:59:36\n     * @author houyu for.houyu@foxmail.com\n     */\n    public interface Constant {\n\n        String CONTENT_TYPE = \"Content-Type\";\n        String RESPONSE_COOKIE = \"Set-Cookie\";  // 获取响应的COOKIE\n        String REQUEST_COOKIE = \"Cookie\";       // 设置发送的COOKIE\n        String REFERER = \"Referer\";\n        String PROXY_AUTHORIZATION = \"Proxy-Authorization\";\n        String CONTENT_ENCODING = \"Content-Encoding\";\n        String LOCATION = \"Location\";\n\n        String CONTENT_TYPE_WITH_FORM = \"application/x-www-form-urlencoded; charset=\";\n        String CONTENT_TYPE_WITH_JSON = \"application/json; charset=\";\n        String GZIP = \"gzip\";\n\n        int REDIRECT_CODE_301 = 301;\n        int REDIRECT_CODE_302 = 302;\n        int REDIRECT_CODE_303 = 303;\n\n        String COOKIE_SPLIT = \"; \";\n        String EQU = \"=\";\n        String UTF_8 = \"UTF-8\";\n        String HTTPS = \"https\";\n        String HTTP = \"http\";\n\n        String AND_SIGN = \"&\";\n\n        String CONTENT_TYPE_WITH_CHARSET = \"charset=\";\n\n        String EMPTY_STRING = \"\";\n        String CHARSET = \"charset\";\n\n    }\n\n}\n\n\n\n```\n\n你可以猜想我那天封装的时候屏幕是这样子的。\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190822172959548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190822173325966.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n\n我的博客 https://shaines.cn\n我的CSDN https://blog.csdn.net/JinglongSource/article/details/100016899', '2019-08-22 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190822172959548.png', NULL, 1, 33, 1, '作为一个爬虫业余爱好者， 网络编程是最基本的知识点，如果想玩爬虫，没有一个方便使用的网络请求工具类, 别谈什么爱好了, 业余都有点业余了, 为此, 我把我之前的一个工具类, 结合我对[面向对象]的理解封装了一下, 如果封装得不好, 有可能我对[面向对象], 有误解吧。', 'http', '面向对象封装一个http工具', '20190713', 'houyu', 0);
INSERT INTO `blog` VALUES ('1167042492900265984', '1154240574968754176', 'A02_JAVA_爬虫', 0, '# 前言:\n> 很多人都说网易云音乐的一条评论是一个故事, 细细一看的话, 你会发现有些评论确实很真， 很性情。\n> 抓取网易云音乐评论主要涉及了参数的加密问题，这篇博客主要是剖析一下如何进行参数的加密以及解密剖析\n> 这里使用的是java进行加密实现数据的抓取。\n\n爬虫有三难：\n* 登录难 如： 淘宝, 12306\n* 参数加密 如: 网易云音乐评论, 企查查, 天眼查, \n* 响应(内容)加密 如: 企查查, 天眼查\n\n\n# 确立需求\n获取“电灯胆”歌词评论， 然后对歌词进行分词处理，获取高频词，制作词云图等\n\n这里主要涉及的的技术点有:\n1. F12的抓包以及快速定位链接\n2. 网页debug js在爬虫中的使用\n3. 爬虫参数加密的剖析过程\n4. java分词工具word的使用\n5. mysql 统计相同\n\n# 先来看一下整体效果\n图一  图二使用的是 [图悦](http://www.picdata.cn) 进行分词统计并且生成词云图\nhttp://www.picdata.cn/picdata/index.php#\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190829172138678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190829172148265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n图三使用的是java word 分词库进行分词, 结合数据库进行统计词频等生成的词云图\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/2019082917220232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n---\n# 具体步骤如下:\n\n\n### 步骤01: 我们随机选择一首歌曲进入页面, 拖到底部查看评论页面\n然后点击下一页, 网页会请求后台获取数据, 我们通过F12抓包可以知道链接地址以及参数等, 如下图:\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190824225734529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n### 步骤02: 参看传递的参数, 如下图\n我们可以了解到\nurl:https://music.163.com/weapi/v1/resource/comments/R_SO_4_1379057027?csrf_token=\nmethod: post\ncontent-type: application/x-www-form-urlencoded\n\nparams:必要参数\nencSecKey: 必要参数\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190824225631302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n### 步骤03: 解析参数来源\n从图一中可以知道发起请求的js是core_97f1bfe….js?97f1bfe\n那么进入这个js查看其源码, 可以发现这个core_xxxx.js的东西竟然是一个4万5千多行的文件\n不过不要慌, 如果真的去看完这个多代码都可以前端 js了, 我想这篇博客也是不知道猴年马月才可以写了\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/2019082423095095.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n### 步骤04: 快速定位加密的js位置\nctrl + f 搜索关键字 \"encSecKey\"\n可以知道了生成参数params encSecKey的参数位置了\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/2019082423151423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n接着往上看两行代码\n\n```js\nvar bUP7I = window.asrsea(JSON.stringify(i8a), brF9w([\"流泪\", \"强\"]), brF9w(WZ4d.md), brF9w([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"]));\n```\n发现是一个 window.asrsea的方法产生的一个对象bUP7I \n在这里留一个心眼, brF9w 这是一个方法, 传递了一些乱七八糟的参数, 但是我在断点了好多次都发现是这几个奇奇怪怪的参数, 非常有意思的网易云音乐呀...\n因此我们在这里可以理解为调用的window.asrsea()方法, \n第一个参数是一个字符串,=>因为看到了JSON.stringify()这个方法\n第二个参数是一个常量\n第三个参数是一个常量\n第四个参数是一个常量\n\n### 步骤05: 找到五个核心方法(a b c d e)\n\n接着我们ctrl + f 搜索关键字 \"asrsea\"\n如下图, 我们这个五个方法进行了深入的了解以及剖析, 就是这几个方法花了我一个星期的空闲时间, 主要是不理解机密, 捣腾了\nwindow.asrsea = d,\nwindow.ecnonasr = e\n可以了解到d方法赋值给window.asrsea, e赋值给window.ecnonasr\n\n因此图四调用的window.asrsea, 实际上就是d方法\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190824232516999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n### 步骤06: debug核心方法d\n在12896行打一个断点, 我们查看一下四个参数究竟是什么东东\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190824233421339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n参数d:\n{\"rid\":\"R_SO_4_1379057027\",\"offset\":\"100\",\"total\":\"false\",\"limit\":\"20\",\"csrf_token\":\"\"}\n\n参数e:\n010001\n\n参数f:\n00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7\n\n参数g:\n0CoJUm6Qyw8W8jud\n\n关键的源码\n```js\n function a(a) {\n        var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\";\n        for (d = 0; a > d; d += 1)\n            e = Math.random() * b.length,\n            e = Math.floor(e),\n            c += b.charAt(e);\n        return c\n    }\n    function b(a, b) {\n        var c = CryptoJS.enc.Utf8.parse(b)\n          , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\")\n          , e = CryptoJS.enc.Utf8.parse(a)\n          , f = CryptoJS.AES.encrypt(e, c, {\n            iv: d,\n            mode: CryptoJS.mode.CBC\n        });\n        return f.toString()\n    }\n    function c(a, b, c) {\n        var d, e;\n        return setMaxDigits(131),\n        d = new RSAKeyPair(b,\"\",c),\n        e = encryptedString(d, a)\n    }\n    function d(d, e, f, g) {\n        var h = {}\n          , i = a(16);\n        return h.encText = b(d, g),\n        h.encText = b(h.encText, i),\n        h.encSecKey = c(i, e, f),\n        h\n    }\n    function e(a, b, d, e) {\n        var f = {};\n        return f.encText = c(a + e, b, d),\n        f\n    }\n    window.asrsea = d,\n    window.ecnonasr = e\n```\n\n结合步骤05的图解, 可以知道方法b是一个加密方法,方法d是一个参数组装方法, \n\n细看方法d, 会发现调用了两次方法b, 也就是加密两次了, 第一次是对参数d, g加密, g是一个常量, 上面以及解析了, 第二次是对第一次机密的结果再次进行加密, 参数i是一个调用了a方法的16为随机数, 因此i也是可以理解为一个常量值, 通过debug, 就可以查到这个常量是什么了\n\n接着再看 h.encSecKey = c(i, e, f),这行代码\n由于 i 可以理解为常量, e 传入d方法的时候也是常量, f 传入d方法的时候也是常量, \n因此可以理解为h.encSecKey也是一个常量, 我们只需要debug, 获取到一个h.encSecKey即可( 但是这个encSecKey和参数 i 需要 同一次debug出来的才可以, 否则有问题的...)\n\n\n### 步骤07: java实现前端的加密算法(js方法b)\n由于这里找了很多资料, 直接提供这个方法出来\nhttps://blog.csdn.net/bicheng4769/article/details/80811676\nhttps://zhidao.baidu.com/question/1819427615658816228.html\n\n```java\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.springframework.util.Base64Utils;\n\n/**\n * @description AESEncrypt加密工具\n * @date 2019-08-24 23:51:19\n * @author houyu for.houyu@foxmail.com\n */\npublic class AESEncrypt {\n\n    public static String encrypt(String content, String sKey) {\n        /*\n         function b(a, b) {\n             var c = CryptoJS.enc.Utf8.parse(b)\n               , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\")\n               , e = CryptoJS.enc.Utf8.parse(a)\n               , f = CryptoJS.AES.encrypt(e, c, {\n                         iv: d,\n                         mode: CryptoJS.mode.CBC\n                     });\n             return f.toString()\n         }\n        // 说明: 前段js没有使用填充模式, 默认使用了PKCS7Padding\n        //\n        // https://zhidao.baidu.com/question/1819427615658816228.html\n        // CryptoJS.enc.Utf8.parse方法才可以将key转为128bit的。好吧，既然说了是多次尝试，那么就不知道原因了，后期再对其进行更深入的研究。\n        // 字符串类型的key用之前需要用uft8先parse一下才能用\n        //\n        // 后端使用的是PKCS5Padding，但是在使用CryptoJS的时候发现根本没有这个偏移，查询后发现PKCS5Padding和PKCS7Padding是一样的东东，使用时默认就是按照PKCS7Padding进行偏移的\n        //\n        // CryptoJS.AES         >> 算法\n        // CBC                  >> 模式\n        // 0102030405060708     >> 偏移量\n        //\n        // 由于CryptoJS生成的密文是一个对象，如果直接将其转为字符串是一个Base64编码过的，在encryptedData.ciphertext上的属性转为字符串才是后端需要的格式。\n         */\n        try {\n            byte[] encryptedBytes;\n            byte[] byteContent = content.getBytes(\"UTF-8\");\n            // 获取cipher对象，getInstance(\"算法/工作模式/填充模式\")\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            // 采用AES方式将密码转化成密钥\n            SecretKeySpec secretKeySpec = new SecretKeySpec(sKey.getBytes(), \"AES\");\n            // 初始化偏移量\n            IvParameterSpec iv = new IvParameterSpec(\"0102030405060708\".getBytes(\"UTF-8\"));\n            //cipher对象初始化 init（“加密/解密,密钥，偏移量”）\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv);\n            //按照上面定义的方式对数据进行处理。\n            encryptedBytes = cipher.doFinal(byteContent);\n            return new String(Base64Utils.encode(encryptedBytes), \"UTF-8\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}\n\n```\n\n### 步骤08: 验证js加密之后的内容与java加密之后的内容是否一致(方法b)\n首先控制相同变量\n参数d:\n{\"rid\":\"R_SO_4_1379057027\",\"offset\":\"100\",\"total\":\"false\",\"limit\":\"20\",\"csrf_token\":\"\"}\n参数g:\n0CoJUm6Qyw8W8jud\n\n浏览器控制台输入\nb(\'{\"rid\":\"R_SO_4_1379057027\",\"offset\":\"100\",\"total\":\"false\",\"limit\":\"20\",\"csrf_token\":\"\"}\', \'0CoJUm6Qyw8W8jud\')\n结果会报如下图错误![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190824235817405.png)\n因此我们需要先定义方法b, 直接把方法b的源码丢到控制台即可\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190825000158883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n后端java加密结果\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190825000228244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n至此 以及实现了java后端加密和js加密一致的内容, 接下来就是比较简单的了,看一下封装对应前段的几个方法即可\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.springframework.util.Base64Utils;\n\n/**\n * @description AESEncrypt加密工具\n * @date 2019-08-24 23:51:19\n * @author houyu for.houyu@foxmail.com\n */\npublic class AESEncrypt {\n\n    /**\n     * @description 对应网易云音乐的方法b\n     * @date 2019-08-25 00:05:05\n     * @author houyu for.houyu@foxmail.com\n     */\n    public static String encrypt(String content, String sKey) {\n        /*\n         function b(a, b) {\n             var c = CryptoJS.enc.Utf8.parse(b)\n               , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\")\n               , e = CryptoJS.enc.Utf8.parse(a)\n               , f = CryptoJS.AES.encrypt(e, c, {\n                         iv: d,\n                         mode: CryptoJS.mode.CBC\n                     });\n             return f.toString()\n         }\n        // 说明: 前段js没有使用填充模式, 默认使用了PKCS7Padding\n        //\n        // https://zhidao.baidu.com/question/1819427615658816228.html\n        // CryptoJS.enc.Utf8.parse方法才可以将key转为128bit的。好吧，既然说了是多次尝试，那么就不知道原因了，后期再对其进行更深入的研究。\n        // 字符串类型的key用之前需要用uft8先parse一下才能用\n        //\n        // 后端使用的是PKCS5Padding，但是在使用CryptoJS的时候发现根本没有这个偏移，查询后发现PKCS5Padding和PKCS7Padding是一样的东东，使用时默认就是按照PKCS7Padding进行偏移的\n        //\n        // CryptoJS.AES         >> 算法\n        // CBC                  >> 模式\n        // 0102030405060708     >> 偏移量\n        //\n        // 由于CryptoJS生成的密文是一个对象，如果直接将其转为字符串是一个Base64编码过的，在encryptedData.ciphertext上的属性转为字符串才是后端需要的格式。\n         */\n        try {\n            byte[] encryptedBytes;\n            byte[] byteContent = content.getBytes(\"UTF-8\");\n            // 获取cipher对象，getInstance(\"算法/工作模式/填充模式\")\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            // 采用AES方式将密码转化成密钥\n            SecretKeySpec secretKeySpec = new SecretKeySpec(sKey.getBytes(), \"AES\");\n            // 初始化偏移量\n            IvParameterSpec iv = new IvParameterSpec(\"0102030405060708\".getBytes(\"UTF-8\"));\n            //cipher对象初始化 init（“加密/解密,密钥，偏移量”）\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv);\n            //按照上面定义的方式对数据进行处理。\n            encryptedBytes = cipher.doFinal(byteContent);\n            return new String(Base64Utils.encode(encryptedBytes), \"UTF-8\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /** 以下参数是js debug获取到的 */\n    public static final String i = \"C3Ba8sQUIHbPHC1Z\";\n    public static final String e = \"\";\n    public static final String f = \"\";\n    public static final String g = \"0CoJUm6Qyw8W8jud\";\n    public static final String encSecKey = \"7c23b7a80684cee814ecdc6252cc66e53a4df5890b1299783e5c575c709e7c8c22d98edc4074fc31b9bf7458e1ab6452c42fde55fcbd9b765f049da3809703686fc86b43ff757a2fa9eb77c0b04a51f02efb3e0ade116454561a6f2aefe89f6d611343383eaf643dce13b4ad1709ea2f8215f922c1a014d7fd79adcd0fa107a4\";\n\n    /**\n     * @description 对应网易云音乐方法d, 其中参数d f g在外边定义好\n     * @date 2019-08-25 00:06:51\n     * @author houyu for.houyu@foxmail.com\n     */\n    public static Map<String, Object> methodD(String pageObject) {\n        String encText = encrypt(pageObject, g);\n        encText = encrypt(encText, i);// C3Ba8sQUIHbPHC1Z\n\n        // 这里就不必要调用方法c了,因为这里是一个固定值, 直接前段js debug出来即可\n        Map<String, Object> paramMap = new HashMap<>(2);\n        paramMap.put(\"params\", encText);\n        paramMap.put(\"encSecKey\", encSecKey);\n        return paramMap;\n    }\n\n    public static Map<String, Object> getParamMap(String rid, int pageIndex, int pageSize){\n        String s = \"{\\\"rid\\\":\\\"%s\\\",\\\"offset\\\":\\\"%s\\\",\\\"total\\\":\\\"false\\\",\\\"limit\\\":\\\"%s\\\",\\\"csrf_token\\\":\\\"\\\"}\";\n        s = String.format(s, rid, (pageIndex - 1) * pageSize, pageSize);\n        return methodD(s);\n    }\n\n}\n\n```\n\n具体源码在上面的git\n\nhttps://github.com/HouYuSource/spider/blob/master/src/main/java/cn/shaines/spider/module/music/Music163Spider.java\n* 代理池抓取\n* 多线程抓取\n\n待完善的地方是：重试机制的建立, 也就是说某一页失败了,加入重新抓取队列中。\n\n### 最后的话\n* 单个IP抓取一定数量之后就会被封IP,建议加上IP池(下面是封IP之后, 网页的评论列表都打不开了)\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/2019082919410429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n* 网易后端限制了中间页数的获取, 也就是说大概有2/5获取不到的.\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190829194227471.png)\n---\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190829194542182.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n---\n我的CSDN:\nhttps://blog.csdn.net/JinglongSource\n\n我的博客:\nhttps://shaines.cn\n\n\n\n\n\n\n\n\n', '2019-08-29 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190829172138678.png', NULL, 1, 37, 1, '很多人都说网易云音乐的一条评论是一个故事, 细细一看的话, 你会发现有些评论确实很真， 很性情。抓取网易云音乐评论主要涉及了参数的加密问题，这篇博客主要是剖析一下如何进行参数的加密以及解密剖析', '网易云音乐,爬虫,爬虫参数解密', '解密网易云音乐评论js加密参数,实现分词处理制作词云图', '20190713', 'houyu', 0);
INSERT INTO `blog` VALUES ('1168578597969592320', '1154239217297715200', 'A04_SQL', 0, '> 一次紧张又刺激的线上sql引发的惨案(CPU:100%)\n\n故事的开始是这样子的，系统需要导入一批量数据， 大概单表的话6万8左右， 数据量不算大， 由于还有关联关系， 所以还在两张表中存储对应的关联\n\n#  -------------坑1 \n由于使用的是程序导入，批量插入， for循环中构建对应到三张表的依赖关系, 外层使用3个List< Entity >存储, 当数据量达到1000, saveBatch一下, 程序看着好像都没问题，但是由于省事嘛， 直接在一个方法体处理完了所有的逻辑， 包括saveBatch的操作, 然后写完了整体代码, 检查一遍, 发现是执行多条(更新 / 添加)的事务, 因此，很负责得在service对应的方法添加了一个注解@Transaction(rollbackFor = Exception.class)\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/2019090300113173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n* 在这里补充一点, 因为Spring的默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。也就是说只有是发生了RuntimeException或者Error级别的报错, 事务才会生效，否则事务不生效的， 所以这里添加了rollbackFor = Exception.class， 这是之前很早踩过的一个坑 **Transaction不生效**\n\n好像没毛病是不是?\n\n代码提交给了大佬， 大佬在本地测试了一遍， 没问题， 一切好像还很正常。。。\n大佬没时间细看, 所以本地测试通过就是干了[奸笑]\n\n直到部署到线上环境，问题就来了。。。。\n\n**大佬说一直没有插入数据...我的天什么情况? {导入过去了5分钟}**\n**什么时候有一个结果?         呜呜呜~~欲哭无泪啊!!!!**\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190903011036227.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n我一下子也是懵逼的, 没道理呀, 我明明1000条插入一次呀!!!  后来看了一下代码发现，在外层添加了事务Transaction，导致了必须是6万8要么成功。 要么失败， 这就有点吓人了。\n\n时间又过了十几分钟， 数据库的数量依旧没有动静， 难道崩了？\n\n还好导入数据的时候添加了日志记录， 发现日志打印正常， 一直在输出， \n\n这个时候内心是崩溃的， 只能在心里默默祈祷不要出错了\n\n虽然最终的结果正常导入了， 但是真的非常不建议这样子玩， 太恐怖了....\n\n### 总结坑一：\n* 事务范围过大， 导致代码锁， 以及表锁\n* 数据库连接池的消耗殆尽，因为启用了事务， 连接池一起占用着。。。（我记得我看过一篇文章是这样子说的，标题是：你的接口真的支持高并发吗？）\n* 数据一致没有动静， 不知道执行情况（幸好多写了几行代码， 记录了一下日志， 可以查看日志得知程序还在正常跑）\n* 数据量过大， 可能直接导致服务器(或者mysql)崩溃， 事务的执行是在数据库级别， 因此， 所以的插入都缓存在mysql中，可能随时崩啊   (这个是我个人目前的知识观点， 可能具体知识点不正确， 但是你想一下， 要么成功要么失败，数据没进入库？哪去哪了？肯定有地方缓存了，因此数据量过大会有崩溃的危险....)\n\n### 改进方案:\n* 缩小事务范围即可, 比如说, 一千条批量插入一次的, 抽取出来一个方法, 在这个方法添加事务, 然后就可能看到1000 1000的入库, 心里踏实很多的...\n\n题外话, 这个东西还真的实在实际生产上才会发现，除非你有类似的经历, 请说出你的故事...\n\n\n#  -------------坑2\n数据库导入数据了, 关联关系也起来了， 但是页面的数据一致出不来，什么情况呢，查看代码， 也没发现有什么问题呀，就是一个简单分页的sql, 在这里我贴了类似的sql出来\n\n```sql\nSELECT t1.*, t3.binding_time FROM yycpark_member_import_temp1 t1\nLEFT JOIN yycpark_member_import_temp2 t2 ON t2.member_number = t1.member_number\nLEFT JOIN yycpark_member_import_temp3 t3 ON t3.member_number = t2.member_number limit 100, 10\n```\n这里的关系是如下图===>>**A大概数据量6万8, B数据量大概8万,  C大概数据量6万8**\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190903002653748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n但是就是出不来, 一直卡着,\n后来大佬突然说是不是没有索引? 我的天呐....................~~我仿佛看到了mysql在呻吟~~\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190903002831645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n但是这个时候, 服务器开始出现异常了\n* CPU%,居高不下, \n* mysql占用率极高\n* 打不开A表， 其他表可以打开\n\n因此表都打不开, 添加索引失败,\n\n在这个过程中, 我们重启了很多次微服务, 发现问题依然存在，甚至都怀疑是不是坑1，事务没释放~~\n\n题外话, 这里说一下公司有金主爸爸...买的是阿里云的数据库, ，这个时候价值就体现了， 阿里云后台数据库监测中心，超级流弊，直接定位到了sql位置，然后发现问题的sql是 ( 类似于下面sql [ 我本地测试的sql ] ，在这里不可能贴实际代码的呢~)\n\n```sql\nSELECT COUNT(1) FROM yycpark_member_import_temp1 t1\nLEFT JOIN yycpark_member_import_temp2 t2 ON t2.member_number = t1.member_number\nLEFT JOIN yycpark_member_import_temp3 t3 ON t3.member_number = t2.member_number\n```\n发现这个会话一直没有关闭，由于之前还以为没请求到后端，然后还猛点了一波，最终发现了大概60  70这这样子的会话....\n\n也就是问题就是这个了sql，但是这个这么简单的sql, 为什么会执行那么久呢?\n这个就是一个分页的SQL， 然后执行查询count的操作呀, 为什么卡住呢?\n\n~~这个时候，系统远方现场的大佬又发话，怎么回事呀， 数据还没出来。。。用户等着用呢~~ \n\n> 在这里，我使用了本地测试了一下， 没有索引的三张表\n\n**A大概数据量6万8, B数据量大概8万,  C大概数据量6万8**\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190903004427388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n现象重现了，一直出不来， 由于我不敢运行多个， 这里只跑了一条sql, 我担心我的小本本炸....\n服务器上可是有60  70这个会话, 因此CPU100%,一直没有下降趋势\n\n后来的处理方式是:\n### 重启mysql服务, 添加对应的索引\n---\n\n然后我本地测试添加索引\n\n可以参考\nhttps://www.cnblogs.com/daimaxuejia/p/7865300.html\nhttps://www.cnblogs.com/sweet521/p/6203360.html\n\n> 使用CREATE 语句创建索引\n> 普通索引\n> CREATE INDEX index_name ON table_name(column_name1,column_name2);\n> \n> 非空索引\n> CREATE UNIQUE INDEX index_name ON table_name (column_name);\n> \n> 主键索引\n> CREATE PRIMARY KEY INDEX index_name ON table_name (column_name);\n> \n> 使用ALTER TABLE语句创建索引\n> alter table table_name add index index_name (column_list);\n> alter table table_name add unique (column_list);\n> alter table table_name add primary key (column_list);\n\n删除索引\ndrop index index_name on table_name ;\nalter table table_name drop index index_name ;\nalter table table_name drop primary key ;\n\n```sql\nCREATE UNIQUE INDEX idx_t1_member_number ON yycpark_member_import_temp1 (member_number);\nCREATE UNIQUE INDEX idx_t2_member_number ON yycpark_member_import_temp2 (member_number);\nCREATE UNIQUE INDEX idx_t3_member_number ON yycpark_member_import_temp3 (member_number);\n```\n然后再次执行sql，瞬间出来了。。。\n\n```sql\nSELECT COUNT(1) FROM yycpark_member_import_temp1 t1\nLEFT JOIN yycpark_member_import_temp2 t2 ON t2.member_number = t1.member_number\nLEFT JOIN yycpark_member_import_temp3 t3 ON t3.member_number = t2.member_number\n```\n\n如下图\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190903005400912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n速度就上来啦   ,问题貌似就解决了，但是这里其实还可以优化sql。。。\n业务的sql是(类似于如下)\n\n```sql\nSELECT t1.*, t3.binding_time FROM yycpark_member_import_temp1 t1\nLEFT JOIN yycpark_member_import_temp2 t2 ON t2.member_number = t1.member_number\nLEFT JOIN yycpark_member_import_temp3 t3 ON t3.member_number = t2.member_number limit 100, 10\n```\n\n改进之后的sql\n\n```sql\nSELECT t1.*, t3.binding_time FROM ( SELECT * FROM yycpark_member_import_temp1 t1 LIMIT 100, 10 ) t1\nLEFT JOIN yycpark_member_import_temp2 t2 ON t2.member_number = t1.member_number\nLEFT JOIN yycpark_member_import_temp3 t3 ON t3.member_number = t2.member_number\n```\n\n* 大佬提供的思路：主要想实现的就是**先单表分页出10条数据，然后再left join** \n\n\n这里主要看业务, 这里呢, 如果使用改进后的sql, 那就意味着, 无法通过t2 t3的where 赛选查询, 只能是单表操作\n\n但是，后来我发现， 这两条sql速度微乎其微, 都**没相差50毫秒**, 也不知道是不是数据量的问题(6.8万)还是执行计划的问题，\n\nps,我不太会查看sql执行计划, 看不懂....\n\n### 改进方案:\n* 线上数据库必须添加索引，否则你都不需要程序睡眠都可以叫用户加钱优化，【捂脸】\n* 这个问题一般也是线上环境才会出现， 本地那几条数据根本不会慢的【奸笑】\n\n至此....\n\n一次紧张又刺激的线上sql引发的惨案(CPU:100%)\n\n今天收获挺大的， 每天进步一点点...\n\n睡觉啦~~~~~~~~晚安\n\n', '2019-09-03 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190903002653748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70', NULL, 1, 39, 1, '一次紧张又刺激的线上sql引发的惨案(CPU:100%)', '线上优化', '一次紧张又刺激的线上sql引发的惨案(CPU:100%)', '20190713', 'houyu', 0);
INSERT INTO `blog` VALUES ('1170589256588591104', '1154239164080386048', 'A03_PYTHON', 0, '# 1.0 python 安装\n> 在window上安装python环境以及集成Anaconda包管理和下载pycharm IDE进行hello world编码\n\n---\n\n> window 安装python环境\n\n### 步骤01\nhttps://www.python.org/downloads/windows/\n\n### 步骤02\n\n ![image](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190908122547304.png)\n\n\n> window 安装 Anaconda 集成库\n\n### 步骤01\nhttps://www.anaconda.com/distribution/#windows\n\n### 步骤02\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190908131035531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n ### 步骤03\n\nconda list 就可以查询现在安装了哪些库，初次安装的包一般比较老，为了避免之后使用报错，可以输入 conda update --all 命令，把所有包进行更新，在提示是否更新的时候输入 y（Yes）让更新继续，等待完成即可。\n\n```shell\nconda update --all\n```\n\n### 步骤04\n建议去到环境变量的用户变量中删除了以下两个变量(安装python 如果勾选了Add Python 3.7 to PATH, 就会默认添加了这两个表变量)\n* C:\\install\\python\\Scripts\\\n* C:\\install\\python\\\n\n\n> window 安装 Pycharm IDE\n\n### 步骤01\n百度搜索 pycharm 进入官方网站下载专业版\n\n### 步骤02\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190908132934340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n### 步骤03\n破解 Pycharm (这里就不尝试永久激活了，因为没必要，真的，永久激活的话更新就不是了，IDE几乎一年已更新，还不如直接使用激活码，半年激活一次即可)\n\n进入网址 http://idea.lanyus.com/ 获取激活码\n如果不提供，那就百度搜索其他激活码吧，都差不多的，能激活使用就行\n\n##### 使用激活码需要修改host文件\n‪C:\\Windows\\System32\\drivers\\etc\\hosts\n复制文件出来然后添加\n```host\n0.0.0.0 account.jetbrains.com\n```\n接着就复制到‪\nC:\\Windows\\System32\\drivers\\etc\\\n目录下，替换即可\n\n##### 这里提供几个激活码出来，也不知道能用多久，过期了就换呗。。。\n\n```shell\nYZVR7WDLV8-eyJsaWNlbnNlSWQiOiJZWlZSN1dETFY4IiwibGljZW5zZWVOYW1lIjoiamV0YnJhaW5zIGpzIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifV0sImhhc2giOiIxMTA1NzI3NC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-rsJR5mlJcjibqRu1gQAMUCngMe8i+AOWIi+JZkNFYPET2G1ONcLPcIzoATTRi6ofkDm5l+3Y4HXjBPjVU6bHDdMBAzCnUqpXKsCknwSYyPSU0Y5pzuLvw6O9aPlQ46UBoTEC2BL5W6f11S7NlAq7tTbDuvFUynqSGAmTEfuZtKmzRmp20ejTPuMlSO7UqSkZvkg6YvSTrax1d2K+P9SAmVGZ9iC7AzBs4AwTf84QB9qHvE/Nh0oELSHWGG9hsZZ7sVghI/39/jPQFTp8GLFsl36ZPybPhGDam721zxS9H++/eJk23Jz3nxaRluE4dWmpHrDg1qBHp8qVpSFejg2QYw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==\n```\n\n```shell\n 56ZS5PQ1RF-eyJsaWNlbnNlSWQiOiI1NlpTNVBRMVJGIiwibGljZW5zZWVOYW1lIjoi5q2j54mI5o6I5p2DIC4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9XSwiaGFzaCI6IjEyMjkxNDk4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-SYSsDcgL1WJmHnsiGaHUWbaZLPIe2oI3QiIneDtaIbh/SZOqu63G7RGudSjf3ssPb1zxroMti/bK9II1ugHz/nTjw31Uah7D0HqeaCO7Zc0q9BeHysiWmBZ+8bABs5vr25GgIa5pO7CJhL7RitXQbWpAajrMBAeZ2En3wCgNwT6D6hNmiMlhXsWgwkw2OKnyHZ2dl8yEL+oV5SW14t7bdjYGKQrYjSd4+2zc4FnaX88yLnGNO9B3U6G+BuM37pxS5MjHrkHqMTK8W3I66mIj6IB6dYXD5nvKKO1OZREBAr6LV0BqRYSbuJKFhZ8nd6YDG20GvW6leimv0rHVBFmA0w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==\n```\n\n### 步骤04\n设置 pycharm 并且编辑hello world\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190908143532980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n\n至此。。。在window上安装python环境以及集成Anaconda包管理和下载pycharm IDE进行hello world编码已经完毕~~\n\n我的CSDN：https://blog.csdn.net/JinglongSource/article/details/100624563\n\n我的博客：https://shaines.cn', '2019-09-08 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190908144621430.png', NULL, 1, 9, 1, '在window上安装python环境以及集成Anaconda包管理和下载pycharm IDE进行hello world编码', 'pycharm,Anaconda', '在window中安装python环境以及Anaconda', '20190713', 'houyu', 0);
INSERT INTO `blog` VALUES ('1174012591540404224', '1154240574968754176', 'A02_JAVA_爬虫', 0, '> 为什么搞这个东西？【java + Selenium实现12306刷票、抢票、购票】\n> 1.主要是12306是爬虫界的一个分水岭，所以我一直想玩12306【本次的实现并非真正意义上的破解12306实现购票，望周知】\n> 2.一直看到微信群，朋友圈，甚至私发的携程 / 同程 购票加油包？点一下增加一个速度的那种~，想自实现一个\n> 3.加深了解一下Selenium库的使用。【Selenium是一个自动化测试的工具库，主要用于测试，但是见仁见智，其实测试的很多东西都可以用于爬虫上面来。】\n> 4.一直没上过12306购票，想了解一下整体购票流程，【其实是没坐过高铁~】\n\n## 首先看看订单生成的效果\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190918001659495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n## 了解一下12306整体购票流程\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190918002935205.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n## 了解一下本次程序的大概流程\n\n* 【___程序】打开浏览器进入12306官网 \n* 【用户___】用户进行**登录**\n* 【___程序】进入搜索车次页面\n* 【用户___】等待用户输入 **出发地** **目的地** **出发日** 等信息\n* 【___程序】进行刷票，预订，提交订单\n* 【___程序】订单生成，打开网易云播放音乐\n* 【用户___】用户**支付**订单\n* 【___程序】购票结束，关闭浏览器\n\n## 运行程序\n* 下拉最新代码 https://github.com/HouYuSource/spider\n具体实现源在：https://github.com/HouYuSource/spider/blob/master/src/main/java/cn/shaines/spider/module/china12306/TicketWorker2.java\n\n```java\npackage cn.shaines.spider.module.china12306;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.apache.commons.lang3.StringUtils;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.interactions.Actions;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.WebDriverWait;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author houyu\n * @createTime 2019/9/1 23:17\n */\npublic class TicketWorker2 {\n\n    private static final Logger logger = LoggerFactory.getLogger(TicketWorker2.class);\n    private static final String loginUrl = \"https://kyfw.12306.cn/otn/resources/login.html\";\n    private static final String indexUrl = \"https://kyfw.12306.cn/otn/view/index.html\";\n    private static final String searchUrl = \"https://kyfw.12306.cn/otn/leftTicket/init\";\n    private static final String confirmUrl = \"https://kyfw.12306.cn/otn/confirmPassenger/initDc\";\n\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // 打印初始化信息\n        init();\n        // 获取驱动\n        WebDriver driver = getWebDriver();\n        // 最大化\n        driver.manage().window().maximize();\n        // 处理登录\n        handleLogin(driver);\n        // 前往搜索\n        handleSearch(driver);\n        // 用户输入的车次\n        String carCode = handleInputCarCode();\n        // 处理预定\n        handleReserve(driver, carCode);\n        // 处理提交\n        handleSubmit(driver);\n        // 处理确认提交信息\n        handleConfirm(driver);\n        // 处理提醒用户\n        handleCallUser(driver);\n        // 睡眠等待用户确认信息完毕\n        Thread.sleep(1000000);\n        // 关闭浏览器\n        driver.close();\n\n\n    }\n\n    private static void handleCallUser(WebDriver driver) throws InterruptedException {\n\n        String windowHandle = driver.getWindowHandle();\n        JavascriptExecutor executor = (JavascriptExecutor) driver;\n        executor.executeScript(\"window.open(\'https://music.163.com/#/song?id=224877\')\");\n        // 切换到网易云窗口\n        Thread.sleep(1000);\n        List<String> windowHandles = new ArrayList<>(driver.getWindowHandles());\n        driver.switchTo().window(windowHandles.get(windowHandles.size() - 1));\n        Thread.sleep(1000);\n        driver.switchTo().frame(\"contentFrame\");\n        Thread.sleep(1000);\n        driver.findElement(By.cssSelector(\"[id=content-operation]>a:first-child\")).click();\n        Thread.sleep(1000);\n        driver.switchTo().window(windowHandle);\n    }\n\n    private static void handleConfirm(WebDriver driver) throws InterruptedException {\n        Thread.sleep(1000);\n        if(driver.findElements(By.cssSelector(\"#checkticketinfo_id #qr_submit_id\")).size() > 0) {\n            // 点击确认订单信息\n            driver.findElements(By.cssSelector(\"#checkticketinfo_id #qr_submit_id\")).get(0).click();\n        }\n        logger.debug(\"购票成功\");\n    }\n\n    private static void handleSubmit(WebDriver driver) throws InterruptedException {\n        Thread.sleep(1000);\n        driver.findElement(By.cssSelector(\"#normalPassenger_0\")).click();\n        //\n        do {\n            if(driver.findElements(By.cssSelector(\"#transforNotice_id #qr_closeTranforDialog_id\")).size() > 0) {\n                // 这里有可能会出现网络繁忙的情况, 如果出现就点击确认, 关闭窗口, 然后再重试\n                driver.findElement(By.cssSelector(\"#transforNotice_id #qr_closeTranforDialog_id\")).click();\n            }\n            Thread.sleep(1000);\n            driver.findElement(By.cssSelector(\"#submitOrder_id\")).click();\n            //\n        } while(driver.findElements(By.cssSelector(\"#transforNotice_id #qr_closeTranforDialog_id\")).size() > 0);\n    }\n\n    private static void handleLogin(WebDriver driver) {\n        driver.get(loginUrl);\n        logger.debug(\"等待用户登录\");\n        // 登录成功\n        WebDriverWait wait = new WebDriverWait(driver, 120);\n        wait.until(ExpectedConditions.urlContains(indexUrl));\n        logger.debug(\"用户登录成功~\");\n    }\n\n    private static void handleReserve(WebDriver driver, String carCode) throws InterruptedException {\n        clickSearch : for (int i = 1; ; i++) {\n            List<WebElement> trs = driver.findElements(By.cssSelector(\"table tbody#queryLeftTable:first-of-type tr\"));\n            for (WebElement tr : trs) {\n                if (tr.getAttribute(\"id\").contains(\"ticket_\")) {\n                    String currentCarCode = tr.findElements(By.cssSelector(\"td div.ticket-info > div.train a.number\")).get(0).getText();\n                    if (carCode.equals(currentCarCode)) {\n                        // 找到了车次\n                        WebElement purchaseTd = tr.findElement(By.cssSelector(\"td:last-of-type\"));\n                        String text = purchaseTd.getText();\n                        logger.debug(\"找到预定text:\" + text);\n                        List<WebElement> aElementList = purchaseTd.findElements(By.tagName(\"a\"));\n                        if (aElementList.size() > 0) {\n                            logger.debug(\"点击预定:\");\n                            purchaseTd.click();\n                            Thread.sleep(1000);\n                            if (driver.findElements(By.id(\"defaultwarningAlert_id\")).size() > 0) {\n                                // 可能出现不可以预定时间\n                                List<WebElement> tips = driver.findElements(By.id(\"content_defaultwarningAlert_hearder\"));\n                                if (tips.size() > 0) {\n                                    String tip = tips.get(0).getText();\n                                    logger.debug(\"预定失败:\" + tip);\n                                }\n                                // 关闭弹窗\n                                driver.findElement(By.id(\"qd_closeDefaultWarningWindowDialog_id\")).click();\n                                continue clickSearch;\n                            }\n                            // 需要处理登录问题\n                            break clickSearch;\n                        }\n                    }\n                }\n            }\n            // 没有找到车次, 或者, 点击查询按钮, 10次刷新一下页面\n            if (i % 10 == 0) {\n                logger.debug(\"重新刷新页面\");\n                driver.navigate().refresh();\n                continue;\n            }\n            long sleepTime = ThreadLocalRandom.current().nextLong(800, 2000);\n            Thread.sleep(sleepTime);\n            List<WebElement> query_ticket = driver.findElements(By.id(\"query_ticket\"));\n            if (query_ticket.size() > 0) {\n                logger.debug(\"准备点击查询更新数据第: \" + i + \" 次\");\n                query_ticket.get(0).click();\n                // 等待页面数据出来\n                WebDriverWait wait = new WebDriverWait(driver, 120);\n                wait.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector(\"table tbody#queryLeftTable:first-of-type tr\")));\n            } else {\n                logger.debug(\"查询按钮不可用\");\n            }\n        }\n    }\n\n    private static String handleInputCarCode() {\n        System.err.println(\"=============================请在下方输入你需要抢购的车次==================================\");\n        String carCode = null;\n        try (Scanner scanner = new Scanner(System.in)) {\n            while (StringUtils.isEmpty(carCode)) {\n                System.out.println();\n                carCode = scanner.nextLine();\n            }\n        }\n        System.out.println(\"您输入的车次为:\" + carCode);\n        return carCode;\n    }\n\n    private static void handleSearch(WebDriver driver) {\n        driver.get(searchUrl);\n        System.out.println();\n        System.err.println(\"请在打开的浏览器页面中填写 \'出发地\' \'目的地\' \'出发日\' 等相关信息, 并且点击 \'查询\' 按钮完成本次操作\");\n        // 获取搜索的条数\n        WebDriverWait wait = new WebDriverWait(driver,120);\n        wait.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector(\"table tbody#queryLeftTable:first-of-type tr\")));\n        List<WebElement> trs = driver.findElements(By.cssSelector(\"table tbody#queryLeftTable:first-of-type tr\"));\n        List<String> currentCarCodeList = new ArrayList<>(16);\n        for (WebElement tr : trs) {\n            if (tr.getAttribute(\"id\").contains(\"ticket_\")) {\n                String currentCarCode = tr.findElements(By.cssSelector(\"td div.ticket-info > div.train a.number\")).get(0).getText();\n                currentCarCodeList.add(currentCarCode);\n            }\n        }\n        System.out.println(\"本次查找到车次数量为: \" + currentCarCodeList.size());\n        for (int i = 0; i < currentCarCodeList.size(); i++) {\n            String currentCarCode = currentCarCodeList.get(i);\n            System.out.print(currentCarCode + \"\\t||\\t\");\n            if (i % 5 == 1) {\n                System.out.println();\n            }\n        }\n    }\n\n    private static void init() {\n        System.out.println();\n        System.out.println(\"‖======================= 欢迎使用 12306 抢票助手 ========================‖\");\n        System.out.println(\"‖                                                                      ‖\");\n        System.out.println(\"‖                                   使用过程中如果有任何问题欢迎反馈       ‖\");\n        System.out.println(\"‖                                   mail : for.houyu@foxmail.com       ‖\");\n        System.out.println(\"‖                                   version : V1.0                     ‖\");\n        System.out.println(\"‖                                   powered by houyu                   ‖\");\n        System.out.println(\"‖                                                                      ‖\");\n        System.out.println(\"‖======================= 欢迎使用 12306 抢票助手 ========================‖\");\n        System.out.println();\n        System.out.println();\n        System.out.println();\n    }\n\n    private static WebDriver getWebDriver() {\n        // System.setProperty(\"webdriver.chrome.driver\", \"C:\\\\install\\\\chromedriver\\\\chromedriver.exe\");// chromedriver地址\n        System.setProperty(\"webdriver.chrome.driver\", \"src/main/resources/chromedriver.exe\");// chromedriver地址\n        WebDriver driver = new ChromeDriver(); // 新建一个WebDriver 的对象，但是new 的是谷歌的驱动\n        return driver;\n    }\n\n}\n\n```\n\n* 安装google浏览器（谷歌内核的浏览器， 版本76.0.3809.132+）\n* 结合程序控制台输出，进行浏览器操作等\n	\n```java\n‖======================= 欢迎使用 12306 抢票助手 ========================‖\n‖                                                                      ‖\n‖                                   使用过程中如果有任何问题欢迎反馈       ‖\n‖                                   mail : for.houyu@foxmail.com       ‖\n‖                                   version : V1.0                     ‖\n‖                                   powered by houyu                   ‖\n‖                                                                      ‖\n‖======================= 欢迎使用 12306 抢票助手 ========================‖\n\n\n\nStarting ChromeDriver 76.0.3809.126 (d80a294506b4c9d18015e755cee48f953ddc3f2f-refs/branch-heads/3809@{#1024}) on port 11230\nOnly local connections are allowed.\nPlease protect ports used by ChromeDriver and related test frameworks to prevent access by malicious code.\n[1568739524.884][WARNING]: Timed out connecting to Chrome, retrying...\n九月 18, 2019 12:58:47 上午 org.openqa.selenium.remote.ProtocolHandshake createSession\n信息: Detected dialect: W3C\n[1568739529.158][WARNING]: Timed out connecting to Chrome, retrying...\n00:58:52.142 [main] DEBUG cn.shaines.spider.module.china12306.TicketWorker2 - 等待用户登录\n...\n...\n```\n\n## Selenium的实现的购票程序优缺点\n> 优点\n\n* 流程简单，快速实现\n* 页面可视化，有感知\n\n> 弊端\n\n* 效率低，性能差【相对而言，其实在这购票上面，你也不敢刷得很快，因为都是实名制的，小心进入黑名单，虽然也有办法规避】\n* 网站购票指南改变，程序不可用\n* 未知问题无法掌握【有可能出现乱七八糟的弹窗都会导致整体的程序挂掉】\n\n## 规划\n* 实现脱离java环境运行，也就是打包为一个.exe文件等形式\n* 进行模块化，组件化，方便日后维护以及打补丁等\n\n## 理想发展\n使用python实现代码级别的破解【可以了解github: 12306 / py12306】\n* 自动打码【网上有开源针对12306的验证码深度学习库，据说准确率高达98%】\n* 自动登录\n* 无限刷票\n* 自动下单\n* 自动支付\n* 订单通知\n\n> 整体流程都看了一遍，发现12306也有几个难点，\n> 其中最难的应该是登录验证码，人看点击都输入错误好几次【这个可接入开源12306打码进行破解】，\n> 其次是请求车次数据的解析，返回的数据有点乱，但是还是有很多可阅读数据的，还没深入DEBUG看，但是感觉不是很难的那种混淆，\n> 除此之外尚未发现比价复杂的点，等闲下来有时间可以玩玩~~\n\n## 最后的话\n* 本程序最后验证时间是:2019-09-17\n* 本程序切勿使用商业用途\n* 程序尚未使用IP池，切勿多实例（启动多次）购票\n* 不会帮助购买票的~但是你在使用过程中遇到什么问题欢迎一起讨论\n* 没有义务帮忙解决一切问题\n\n---\n\n如果你也是一名爬虫爱好者，或者有了解过12306的相关爬虫，欢迎我们一起讨论\nblog: https://shaines.cn\nmail : for.houyu@foxmail.com\ncsdn: https://blog.csdn.net/jinglongsou\n\n\n\n\n', '2019-09-18 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190918012940947.png', NULL, 1, 52, 1, '【java + Selenium实现12306刷票、抢票、购票】', 'selenium,12306,刷票', 'java + Selenium实现12306刷票、抢票、购票', '20190713', 'houyu', 0);
INSERT INTO `blog` VALUES ('1175099852960956416', '1154239115950747648', 'A02_JAVA', 0, '> java基础之 java程序是如何运行起来的?  【 javac 编译 .java 生成.class 】 【java执行.class文件】\n> java基础之 你真的了解main方法吗?你知道args是有什么用吗?\n\n### 1.编写基础代码\n\n```java\npackage cn.shaines.test;\n\nimport java.util.Arrays;\n\n/**\n * @author houyu\n * @createTime 2019/9/20 23:46\n */\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"hello running~\");\n        System.out.println(\"Arrays.toString(args) = \" + Arrays.toString(args));\n        System.out.println(\"MyName:\" + System.getProperty(\"MyName\"));\n    }\n}\n```\n\n### 2.编译.java文件生成.class文件\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190921010322491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n> 脚本代码\n\n```java\njavac Test.java\n```\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190921010335690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n\n### 3.0构建包路径\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190921010353679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n### 4.0执行.class文件\n\n> 脚本代码\n\n```java\njava cn.shaines.test.Test\n```\n\n-D携带参数(-Dname=value), 通过System.getProperty(name)获取\n```java\njava -DMyName=houyu cn.shaines.test.Test\n```\n\n最后携带的参数(String, 并非name=value的形式, 在这里我只是写成name=value的形式)通过main(String[] args)中获取\n```java\njava -DMyName=houyu cn.shaines.test.Test AA=11 BB=22\n```\n\n![在这里插入图片描述](https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190921011841516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppbmdsb25nU291cmNl,size_16,color_FFFFFF,t_70)\n\n\n* 这个用法同理可以使用于任意java程序，你打成 jar 也可以通过以上形式传递参数到程序中\n* 有时间再去写一篇关于如何把 .jar 打包成为 .exe 文件, 并且移植到没有java环境的机器运行\n', '2019-09-21 00:00:00', 'https://shaines.cn/view/image?src=https://img-blog.csdnimg.cn/20190921011841516.png', NULL, 1, 8, 1, '> java基础之 java程序是如何运行起来的?  【 javac 编译 .java 生成.class 】 【java执行.class文件】\n> java基础之 你真的了解main方法吗?你知道args是有什么用吗?', 'java', 'java是如何运行起来的(执行java文件)?你知道main方法中的args是有哪些用处吗?', '20190713', 'houyu', 0);

-- ----------------------------
-- Table structure for catalog
-- ----------------------------
DROP TABLE IF EXISTS `catalog`;
CREATE TABLE `catalog`  (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `catalog_name` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `user_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of catalog
-- ----------------------------
INSERT INTO `catalog` VALUES ('1150036060646944768', 'A01_不分类', '20190713', 'houyu');
INSERT INTO `catalog` VALUES ('1154239115950747648', 'A02_JAVA', '20190713', 'houyu');
INSERT INTO `catalog` VALUES ('1154239164080386048', 'A03_PYTHON', '20190713', 'houyu');
INSERT INTO `catalog` VALUES ('1154239217297715200', 'A04_SQL', '20190713', 'houyu');
INSERT INTO `catalog` VALUES ('1154239661877161984', 'A05_前端', '20190713', 'houyu');
INSERT INTO `catalog` VALUES ('1154240574968754176', 'A02_JAVA_爬虫', '20190713', 'houyu');
INSERT INTO `catalog` VALUES ('1154241060761432064', 'A02_JAVA_框架', '20190713', 'houyu');
INSERT INTO `catalog` VALUES ('1154241584416092160', 'A07_其他', '20190713', 'houyu');
INSERT INTO `catalog` VALUES ('1154242259585789952', 'A06_部署', '20190713', 'houyu');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `blog_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `blog_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `content` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `create_date` datetime(0) NULL DEFAULT NULL,
  `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `status` int(11) NULL DEFAULT NULL,
  `to_email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('1162014465589960704', '1161971192330641408', '如何优雅的编写java代码, 这些奇技淫巧你都知道吗', '牛逼死死得', '2019-08-15 22:53:32', '2857113935@qq.com', 1, '');

-- ----------------------------
-- Table structure for link
-- ----------------------------
DROP TABLE IF EXISTS `link`;
CREATE TABLE `link`  (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `src` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `text` varchar(18) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of link
-- ----------------------------
INSERT INTO `link` VALUES ('1155011034929086464', 'https://admin.shaines.cn', 'A01_后台管理中心');
INSERT INTO `link` VALUES ('1155011422646353920', 'https://kyuuu.be', 'A02_QB');

-- ----------------------------
-- Table structure for log
-- ----------------------------
DROP TABLE IF EXISTS `log`;
CREATE TABLE `log`  (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `browser` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_date` datetime(0) NULL DEFAULT NULL,
  `ip` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `ip_address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `param` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `port` int(11) NULL DEFAULT NULL,
  `result` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `status` int(11) NULL DEFAULT NULL,
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `avatar` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_date` datetime(0) NULL DEFAULT NULL,
  `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `role` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `username` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `UK_sb8bbouer5wak8vyiiy4pf2bx`(`username`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('2', '2', '2019-07-14 20:50:54', 'test@qq.com', 'e8eecd92c00e7184d34fb15773cda0d6', 'USER', 'test');
INSERT INTO `user` VALUES ('20190713', '1', '2019-07-14 19:58:47', 'for.houyu@qq.com', 'e8eecd92c00e7184d34fb15773cda0d6', 'ADMIN', 'houyu');

-- ----------------------------
-- Table structure for vote
-- ----------------------------
DROP TABLE IF EXISTS `vote`;
CREATE TABLE `vote`  (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `blog_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `blog_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `create_date` datetime(0) NULL DEFAULT NULL,
  `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of vote
-- ----------------------------
INSERT INTO `vote` VALUES ('1153661785972887552', '1150333189655404544', 'Java接入支付宝支付(alipay)', '2019-07-23 21:42:58', '272649308@qq.com');
INSERT INTO `vote` VALUES ('1154192329638866944', '1150038168796479488', '关于', '2019-07-25 08:51:10', '272694308@qq.com');
INSERT INTO `vote` VALUES ('1162014452210130944', '1161971192330641408', '如何优雅的编写java代码, 这些奇技淫巧你都知道吗', '2019-08-15 22:53:29', '2857113935@qq.com');
INSERT INTO `vote` VALUES ('1162015313611120640', '1161971192330641408', '如何优雅的编写java代码, 这些奇技淫巧你都知道吗', '2019-08-15 22:56:55', '272694308@qq.com');
INSERT INTO `vote` VALUES ('1164076273305866240', '1161971192330641408', '如何优雅的编写java代码, 这些奇技淫巧你都知道吗', '2019-08-21 15:26:26', '179714467@qq.com');

-- ----------------------------
-- Procedure structure for in_param
-- ----------------------------
DROP PROCEDURE IF EXISTS `in_param`;
delimiter ;;
CREATE DEFINER=`root`@`localhost` PROCEDURE `in_param`(IN p_in int)
BEGIN
--             SELECT p_in;
--             SET p_in=2;
            SELECT * FROM blog;
        END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for test1
-- ----------------------------
DROP PROCEDURE IF EXISTS `test1`;
delimiter ;;
CREATE DEFINER=`root`@`localhost` PROCEDURE `test1`(IN p_in VARCHAR(255))
BEGIN
--             SELECT p_in;
--             SET p_in=2;
            SELECT p_in;
        END
;;
delimiter ;

SET FOREIGN_KEY_CHECKS = 1;
